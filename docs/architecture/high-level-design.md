# High-level Design — Архітектура, рішення, стиль

**Останнє оновлення:** 30.09.2025

---

## 1. Короткий огляд

Проєкт — монолітна веб-платформа з бекендом на Go та фронтендом на React. Архітектурний підхід — трьохшаровий (presentation — service/logic — persistence). Основна база даних — PostgreSQL. Цей документ узагальнює мотиви вибору, наслідки й практичні рекомендації для розробки та підтримки.

---

## 2. Вибір технологій (з ADR)

### 2.1. Go для бекенду (ADR-0001)
- **Дата:** 28.09.2025 — **Статус:** Прийнято — **Автор:** Артур Ключка
- **Чому:** статична типізація, ефективні горутини для асинхронності, хороша підтримка одночасних WebSocket-з'єднань, знайомство частини команди.
- **Наслідки:** бекенд розробляється на Go; фокус на типобезпеці й конкурентності; архітектурні патерни мають враховувати обробку великої кількості відкритих з'єднань.

### 2.2. React для фронтенду (ADR-0002)
- **Дата:** 28.09.2025 — **Статус:** Прийнято — **Автор:** Артур Ключка
- **Чому:** популярність, знайомство команди, багата екосистема компонентів.
- **Наслідки:** SPA на React; використовувати сучасні best-practices (функціональні компоненти, hooks, централізоване управління станом там, де потрібно).

### 2.3. Архітектурний стиль — трьохшаровий підхід (ADR-0003)
- **Дата:** 30.09.2025 — **Статус:** Прийнято — **Автор:** Владислав Панько
- **Чому:** проєкт має просту бізнес-логіку; складні архітектурні підходи (DDD, Hexagonal, Clean) відхилені як надмірні.
- **Наслідки:** чітке розділення Presentation / Business Logic / Persistence; простіша підтримка й тестування; можливий невеликий оверхед на виклики між шарами.

### 2.4. PostgreSQL як основна БД (ADR-0005)
- **Дата:** 30.09.2025 — **Статус:** Прийнято — **Автор:** Олексій Костик
- **Чому:** надійні транзакції, підтримка паралельних записів і бекап/реплікації, робота з великими файлами та метаданими.
- **Відкинуто:** SQLite (через обмеження конкурентності та опцій для продакшену).
- **Наслідки:** централізоване зберігання даних і файлів у PostgreSQL; операційна складність — плани бекапів, відновлення, моніторинг.

---

## 3. Рекомендована архітектура (деталі)

### 3.1. Тривимірна (триступенева) структура
- **Presentation layer (API / HTTP / WebSockets)**
  - REST/HTTP API для CRUD/синхронних операцій.
  - WebSocket-ручки для реального часу (collaboration, автозбереження).
  - Авторизація/аутентифікація (JWT або cookie-based, залежно від безпекових вимог).

- **Service / Business Logic layer**
  - Точка виконання правил бізнесу, транзакційні сцени.
  - Оркестрація доступу до репозиторіїв, валідація, rate-limiting для важких операцій.

- **Persistence layer**
  - Репозиторії, що інкапсулюють доступ до PostgreSQL.
  - Модель даних: таблиці для файлів, версій, коментарів, користувачів, сесій.
  - Транзакції для операцій, що змінюють багато сутностей одночасно.

### 3.2. Комунікація між шарами
- Використовувати чітко визначені інтерфейси (Go interfaces) для впровадження залежностей та полегшення тестування.
- Не уводити складні патерни DI — прості фабрики й конструктори достатні для моноліту.

### 3.3. Масштабування
- Моноліт разом з PostgreSQL у перших релізах.
- Горизонтальне масштабування API-шарів за потреби (stateless HTTP, sticky sessions або зовнішнє зберігання сесій для WebSocket-координування).
- Для WebSocket масштабу — розглянути Redis Pub/Sub або зовнішній брокер повідомлень для синхронізації стану між інстансами.

---

## 4. Нерозривні нефункціональні вимоги (коротко)
- **Concurrency:** Go + PostgreSQL забезпечують очікувану паралельну обробку; тестувати під навантаженням за сценаріями з великою кількістю WebSocket-з'єднань.
- **Надійність/Відновлення:** регулярно налаштовані бекапи PostgreSQL; план відновлення.
- **Безпека:** аутентифікація, авторизація, TLS для трафіку, захист від CSRF/XXS для фронтенду.

---

## 5. Рекомендації по стилю коду та практики розробки

### 5.1. Бекенд (Go)
- Дотримуватись офіційного `gofmt` / `go fmt` та лінтерів (golangci-lint).
- Структура пакунків по доменам/модулям у межах трьох шарів: `api/`, `service/`, `repo/`, `model/`, `internal/`.
- Інтерфейси для зовнішніх залежностей (DB, cache, email) — в окремому package `ports` або `interfaces`.
- Тестування: unit-tests для сервісів, інтеграційні тести з тестовою PostgreSQL (docker-compose або тестова база).
- Логування: структуроване логування (з контекстом request_id).

### 5.2. Фронтенд (React)
- Файловий стиль: компоненти у `src/components`, сторінки у `src/pages`, hooks у `src/hooks`.
- Використовувати функціональні компоненти та hooks.
- Централізоване управління станом тільки там, де потрібно (наприклад, Redux/VALUE or Zustand) — уникати глобального state без потреби.
- Тестування: unit-тести компонентів (Jest + React Testing Library) і e2e (Playwright / Cypress).

### 5.3. База даних
- Міграції через інструмент (наприклад, golang-migrate або інший обраний інструмент).
- Явні індекси для полів пошуку/фільтрації.
- Ведення історії файлів/версій у зрозумілій схемі (версування, мітки часу, автори змін).

---

## 6. Операційні процедури та DevOps (коротко)
- CI: запуск лінтерів, unit та інтеграційних тестів; перевірка міграцій.
- CD/Deploy: автоматичні збірки докер-образів; деплой на staging/production із перевіркою health-check.
- Моніторинг: метрики (Prometheus) та логування (ELK/EFK або інший стек).
- Бекапи: регулярні повні та інкрементальні бекапи PostgreSQL; тестове відновлення раз на реліз.

---

## 7. Відкриті питання
- Стратегія горизонтального масштабування WebSocket (чіткий план з Redis Pub/Sub або іншою механікою синхронізації).
- Вибір конкретних бібліотек/інструментів для сесій, міграцій та rate-limiting — уточнити в окремих ADR або технічних нотатках.

---

## 8. Додатки: посилання на ADR (зведення)
- ADR-0001 — Вибір Go як мови бекенду (28.09.2025). Автор: Артур Ключка.
- ADR-0002 — Вибір React як фреймворку фронтенду (28.09.2025). Автор: Артур Ключка.
- ADR-0003 — Архітектурний стиль (три шари) (30.09.2025). Автор: Владислав Панько.
- ADR-0005 — Вибір PostgreSQL як основної БД (30.09.2025). Автор: Олексій Костик.

---

