
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ukma-cs-ssdm-2025/team-circus/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/ukma-cs-ssdm-2025/team-circus/docs/docs.go (0.0%)</option>
				
				<option value="file2">github.com/ukma-cs-ssdm-2025/team-circus/internal/app/app.go (0.0%)</option>
				
				<option value="file3">github.com/ukma-cs-ssdm-2025/team-circus/internal/app/setup.go (0.0%)</option>
				
				<option value="file4">github.com/ukma-cs-ssdm-2025/team-circus/internal/config/config.go (0.0%)</option>
				
				<option value="file5">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/auth/login.go (72.5%)</option>
				
				<option value="file6">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/auth/logout.go (100.0%)</option>
				
				<option value="file7">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/auth/refresh.go (58.3%)</option>
				
				<option value="file8">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/auth/requests/login.go (0.0%)</option>
				
				<option value="file9">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/create.go (100.0%)</option>
				
				<option value="file10">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/delete.go (100.0%)</option>
				
				<option value="file11">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/handlers.go (100.0%)</option>
				
				<option value="file12">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/read.go (92.6%)</option>
				
				<option value="file13">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/requests/create.go (0.0%)</option>
				
				<option value="file14">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/requests/update.go (0.0%)</option>
				
				<option value="file15">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/update.go (100.0%)</option>
				
				<option value="file16">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/create.go (87.1%)</option>
				
				<option value="file17">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/delete.go (100.0%)</option>
				
				<option value="file18">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/handlers.go (100.0%)</option>
				
				<option value="file19">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/read.go (100.0%)</option>
				
				<option value="file20">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/requests/create.go (0.0%)</option>
				
				<option value="file21">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/requests/update.go (0.0%)</option>
				
				<option value="file22">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/update.go (100.0%)</option>
				
				<option value="file23">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/create.go (100.0%)</option>
				
				<option value="file24">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/delete.go (100.0%)</option>
				
				<option value="file25">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/handlers.go (100.0%)</option>
				
				<option value="file26">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/read.go (100.0%)</option>
				
				<option value="file27">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/requests/create.go (0.0%)</option>
				
				<option value="file28">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/requests/update.go (0.0%)</option>
				
				<option value="file29">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/update.go (100.0%)</option>
				
				<option value="file30">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/reg/handlers.go (100.0%)</option>
				
				<option value="file31">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/reg/register.go (100.0%)</option>
				
				<option value="file32">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/reg/requests/register.go (0.0%)</option>
				
				<option value="file33">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/user/delete.go (100.0%)</option>
				
				<option value="file34">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/user/handlers.go (100.0%)</option>
				
				<option value="file35">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/user/read.go (100.0%)</option>
				
				<option value="file36">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/user/requests/update.go (0.0%)</option>
				
				<option value="file37">github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/user/update.go (100.0%)</option>
				
				<option value="file38">github.com/ukma-cs-ssdm-2025/team-circus/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file39">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/document/create.go (0.0%)</option>
				
				<option value="file40">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/document/delete.go (0.0%)</option>
				
				<option value="file41">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/document/read.go (0.0%)</option>
				
				<option value="file42">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/document/repo.go (0.0%)</option>
				
				<option value="file43">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/document/update.go (0.0%)</option>
				
				<option value="file44">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/group/create.go (0.0%)</option>
				
				<option value="file45">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/group/delete.go (0.0%)</option>
				
				<option value="file46">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/group/read.go (0.0%)</option>
				
				<option value="file47">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/group/repo.go (0.0%)</option>
				
				<option value="file48">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/group/update.go (0.0%)</option>
				
				<option value="file49">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/member/create.go (0.0%)</option>
				
				<option value="file50">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/member/delete.go (0.0%)</option>
				
				<option value="file51">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/member/read.go (0.0%)</option>
				
				<option value="file52">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/member/repo.go (0.0%)</option>
				
				<option value="file53">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/member/update.go (0.0%)</option>
				
				<option value="file54">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/reg/register.go (0.0%)</option>
				
				<option value="file55">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/reg/repo.go (0.0%)</option>
				
				<option value="file56">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/user/delete.go (0.0%)</option>
				
				<option value="file57">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/user/read.go (0.0%)</option>
				
				<option value="file58">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/user/repo.go (0.0%)</option>
				
				<option value="file59">github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/user/update.go (0.0%)</option>
				
				<option value="file60">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/document/create.go (0.0%)</option>
				
				<option value="file61">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/document/delete.go (0.0%)</option>
				
				<option value="file62">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/document/read.go (0.0%)</option>
				
				<option value="file63">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/document/service.go (0.0%)</option>
				
				<option value="file64">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/document/update.go (0.0%)</option>
				
				<option value="file65">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/group/create.go (0.0%)</option>
				
				<option value="file66">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/group/delete.go (0.0%)</option>
				
				<option value="file67">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/group/read.go (0.0%)</option>
				
				<option value="file68">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/group/service.go (0.0%)</option>
				
				<option value="file69">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/group/update.go (0.0%)</option>
				
				<option value="file70">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/member/create.go (0.0%)</option>
				
				<option value="file71">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/member/delete.go (0.0%)</option>
				
				<option value="file72">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/member/read.go (0.0%)</option>
				
				<option value="file73">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/member/service.go (0.0%)</option>
				
				<option value="file74">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/member/update.go (0.0%)</option>
				
				<option value="file75">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/reg/register.go (0.0%)</option>
				
				<option value="file76">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/reg/service.go (0.0%)</option>
				
				<option value="file77">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/user/delete.go (0.0%)</option>
				
				<option value="file78">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/user/read.go (0.0%)</option>
				
				<option value="file79">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/user/service.go (0.0%)</option>
				
				<option value="file80">github.com/ukma-cs-ssdm-2025/team-circus/internal/service/user/update.go (0.0%)</option>
				
				<option value="file81">github.com/ukma-cs-ssdm-2025/team-circus/pkg/logging/logging.go (0.0%)</option>
				
				<option value="file82">github.com/ukma-cs-ssdm-2025/team-circus/tests/pkg/seeder/seeder.go (0.0%)</option>
				
				<option value="file83">github.com/ukma-cs-ssdm-2025/team-circus/tests/pkg/seeder/user.go (0.0%)</option>
				
				<option value="file84">github.com/ukma-cs-ssdm-2025/team-circus/tests/pkg/testapp/app.go (0.0%)</option>
				
				<option value="file85">github.com/ukma-cs-ssdm-2025/team-circus/tests/pkg/testdb/db.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// @title Team Circus API
// @version 1.0
// @description API for Team Circus project
// @termsOfService http://swagger.io/terms/

// @host localhost:8080
// @BasePath /api/v1

package main

import (
        "context"
        "os/signal"
        "syscall"

        _ "github.com/swaggo/gin-swagger"
        _ "github.com/ukma-cs-ssdm-2025/team-circus/docs"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/app"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/config"
        "github.com/ukma-cs-ssdm-2025/team-circus/pkg/logging"
        "go.uber.org/zap"
)

func main() <span class="cov0" title="0">{
        l := logging.NewLogger()
        ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGTERM, syscall.SIGINT)
        defer cancel()
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                l.Panic("Failed to load config", zap.Error(err))
        }</span>
        <span class="cov0" title="0">l.Info("Creating app...")
        app := app.New(cfg, l)
        l.Info("App created")

        l.Info("Running app...")
        if err := app.Run(ctx); err != nil </span><span class="cov0" title="0">{
                l.Panic("Failed to run app", zap.Error(err))
        }</span>

        <span class="cov0" title="0">l.Info("App stopped successfully")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by swaggo/swag. DO NOT EDIT.

package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticates user credentials, creates and saves JWT access/refresh tokens in cookies.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "User login request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.LogInRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid request format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Invalid credentials",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "description": "Expires the JWT access/refresh cookies.",
                "tags": [
                    "auth"
                ],
                "summary": "User logout",
                "responses": {
                    "204": {
                        "description": "Logged out successfully"
                    }
                }
            }
        },
        "/auth/refresh": {
            "post": {
                "description": "Validates the refresh token cookie and issues a new access/refresh token pair",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Refresh access token",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Cookie header containing refreshToken cookie",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Tokens refreshed successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "401": {
                        "description": "Invalid or expired refresh token",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/documents": {
            "get": {
                "description": "Retrieve a list of all documents belonging to groups the requesting user is a member of",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "documents"
                ],
                "summary": "Get all documents",
                "responses": {
                    "200": {
                        "description": "Documents retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.GetAllDocumentsResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new document with the provided group UUID, name and content",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "documents"
                ],
                "summary": "Create a new document",
                "parameters": [
                    {
                        "description": "Document creation request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateDocumentRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Document created successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateDocumentResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/documents/{uuid}": {
            "get": {
                "description": "Retrieve a specific document by its UUID if the requesting user is a member of the owning group",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "documents"
                ],
                "summary": "Get a document by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Document UUID",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Document retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.GetDocumentResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid UUID format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "401": {
                        "description": "Authentication required",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "403": {
                        "description": "Access forbidden",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Document not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Update a specific document's name and content by its UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "documents"
                ],
                "summary": "Update a document by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Document UUID",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Document update request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateDocumentRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Document updated successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateDocumentResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid UUID format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Document not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a specific document by its UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "documents"
                ],
                "summary": "Delete a document by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Document UUID",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Document deleted successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.DeleteDocumentResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid UUID format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Document not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/groups": {
            "get": {
                "description": "Retrieve a list of all groups the requesting user belongs to",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "summary": "Get all groups",
                "responses": {
                    "200": {
                        "description": "Groups retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.GetAllGroupsResponse"
                        }
                    },
                    "401": {
                        "description": "Authentication required",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new group with the provided name",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "summary": "Create a new group",
                "parameters": [
                    {
                        "description": "Group creation request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.CreateGroupRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Group created successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.CreateGroupResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/groups/{uuid}": {
            "get": {
                "description": "Retrieve a specific group by its UUID if the requesting user is a member",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "summary": "Get a group by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Group UUID",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Group retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.GetGroupResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid UUID format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "401": {
                        "description": "Authentication required",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "403": {
                        "description": "Access forbidden",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Group not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Update a specific group's name by its UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "summary": "Update a group by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Group UUID",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Group update request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateGroupRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Group updated successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateGroupResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid UUID format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Group not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a specific group by its UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "groups"
                ],
                "summary": "Delete a group by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Group UUID",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Group deleted successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.DeleteGroupResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid UUID format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Group not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/signup": {
            "post": {
                "description": "Register a new user with the provided login, email and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "registration"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User registration request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.RegRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User registered successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.RegResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/users": {
            "get": {
                "description": "Retrieve a list of all users",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get all users",
                "responses": {
                    "200": {
                        "description": "Users retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.GetAllUsersResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/users/{uuid}": {
            "get": {
                "description": "Retrieve a specific user by their UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get a user by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User UUID",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.GetUserResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid UUID format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "User not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "description": "Update a specific user's login, email and password by their UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Update a user by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User UUID",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "User update request",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/requests.UpdateUserRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User updated successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateUserResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid UUID format or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "User not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a specific user by their UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Delete a user by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User UUID",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User deleted successfully",
                        "schema": {
                            "$ref": "#/definitions/responses.DeleteUserResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid UUID format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "User not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "requests.CreateDocumentRequest": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "group_uuid": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "requests.CreateGroupRequest": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                }
            }
        },
        "requests.LogInRequest": {
            "type": "object",
            "properties": {
                "login": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "requests.RegRequest": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "login": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateDocumentRequest": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateGroupRequest": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                }
            }
        },
        "requests.UpdateUserRequest": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "login": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "responses.CreateDocumentResponse": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "group_uuid": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "responses.CreateGroupResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "responses.DeleteDocumentResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "responses.DeleteGroupResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "responses.DeleteUserResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "responses.GetAllDocumentsResponse": {
            "type": "object",
            "properties": {
                "documents": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.GetDocumentResponse"
                    }
                }
            }
        },
        "responses.GetAllGroupsResponse": {
            "type": "object",
            "properties": {
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.GetGroupResponse"
                    }
                }
            }
        },
        "responses.GetAllUsersResponse": {
            "type": "object",
            "properties": {
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/responses.GetUserResponse"
                    }
                }
            }
        },
        "responses.GetDocumentResponse": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "group_uuid": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "responses.GetGroupResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "responses.GetUserResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "login": {
                    "type": "string"
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "responses.RegResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "login": {
                    "type": "string"
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "responses.UpdateDocumentResponse": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "group_uuid": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "responses.UpdateGroupResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "uuid": {
                    "type": "string"
                }
            }
        },
        "responses.UpdateUserResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "login": {
                    "type": "string"
                },
                "uuid": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Team Circus API",
        Description:      "API for Team Circus project",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "context"
        "database/sql"
        "fmt"
        "net/http"
        "time"

        _ "github.com/lib/pq"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/config"
        "go.uber.org/zap"
)

const (
        shutdownTimeout = 20 * time.Second
        readTimeout     = 15 * time.Second
)

type App struct {
        cfg *config.Config
        DB  *sql.DB
        API *http.Server
        l   *zap.Logger
}

func New(cfg *config.Config, l *zap.Logger) *App <span class="cov0" title="0">{
        return &amp;App{
                cfg: cfg,
                l:   l,
        }
}</span>

func (a *App) Run(ctx context.Context) error <span class="cov0" title="0">{
        var err error

        // db
        a.DB, err = sql.Open(a.cfg.DB.Driver, a.cfg.DB.DSN())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a.l.Info("DB connected")

        // api
        router := a.setupRouter()
        a.API = &amp;http.Server{
                Addr:        ":" + a.cfg.Srv.Port,
                Handler:     router,
                ReadTimeout: readTimeout,
        }
        go func() </span><span class="cov0" title="0">{
                if err := a.API.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        a.l.Error("API server error", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">a.l.Info("API server started", zap.String("port", a.cfg.Srv.Port))

        // wait for shutdown signal
        &lt;-ctx.Done()
        a.l.Info("Shutdown signal received")

        // graceful shutdown
        timeoutCtx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()
        a.l.Info("Shutting down...")
        err = a.shutdown(timeoutCtx)
        if err != nil </span><span class="cov0" title="0">{
                a.l.Error("Shutdown error", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (a *App) shutdown(timeoutCtx context.Context) error <span class="cov0" title="0">{
        var shutdownErr error

        // api
        if a.API != nil </span><span class="cov0" title="0">{
                if err := a.API.Shutdown(timeoutCtx); err != nil </span><span class="cov0" title="0">{
                        wrapped := fmt.Errorf("shutdown api server: %w", err)
                        a.l.Error("Shutdown API server error", zap.Error(wrapped))
                        shutdownErr = wrapped
                }</span> else<span class="cov0" title="0"> {
                        a.l.Info("API server shutdown successfully")
                }</span>
        }

        // db
        <span class="cov0" title="0">if a.DB != nil </span><span class="cov0" title="0">{
                if err := a.DB.Close(); err != nil </span><span class="cov0" title="0">{
                        wrapped := fmt.Errorf("shutdown db: %w", err)
                        a.l.Error("Shutdown DB error", zap.Error(wrapped))
                        if shutdownErr == nil </span><span class="cov0" title="0">{
                                shutdownErr = wrapped
                        }</span>
                } else<span class="cov0" title="0"> {
                        a.l.Info("DB shutdown successfully")
                }</span>
        }
        <span class="cov0" title="0">return shutdownErr</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        swaggerfiles "github.com/swaggo/files"
        ginswagger "github.com/swaggo/gin-swagger"
        authhandler "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/auth"
        documenthandler "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document"
        grouphandler "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group"
        memberhandler "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member"
        reghandler "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/reg"
        userhandler "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/user"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/middleware"
        documentrepo "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/document"
        grouprepo "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/group"
        memberrepo "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/member"
        regrepo "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/reg"
        userrepo "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/user"
        documentservice "github.com/ukma-cs-ssdm-2025/team-circus/internal/service/document"
        groupservice "github.com/ukma-cs-ssdm-2025/team-circus/internal/service/group"
        memberservice "github.com/ukma-cs-ssdm-2025/team-circus/internal/service/member"
        regservice "github.com/ukma-cs-ssdm-2025/team-circus/internal/service/reg"
        userservice "github.com/ukma-cs-ssdm-2025/team-circus/internal/service/user"
)

func (a *App) setupRouter() *gin.Engine <span class="cov0" title="0">{
        router := gin.Default()

        // CORS middleware
        router.Use(cors.New(cors.Config{
                AllowOrigins:     a.cfg.CORS.AllowOrigins,
                AllowMethods:     a.cfg.CORS.AllowMethods,
                AllowHeaders:     a.cfg.CORS.AllowHeaders,
                ExposeHeaders:    a.cfg.CORS.ExposeHeaders,
                AllowCredentials: a.cfg.CORS.AllowCredentials,
                MaxAge:           time.Duration(a.cfg.CORS.MaxAge) * time.Second,
        }))

        // Swagger documentation
        router.GET("/swagger/*any", ginswagger.WrapHandler(swaggerfiles.Handler))

        groupRepo := grouprepo.NewGroupRepository(a.DB)
        memberRepo := memberrepo.NewMemberRepository(a.DB)
        groupService := groupservice.NewGroupService(groupRepo, memberRepo)

        documentRepo := documentrepo.NewDocumentRepository(a.DB)
        documentService := documentservice.NewDocumentService(documentRepo, groupRepo)

        userRepo := userrepo.NewUserRepository(a.DB)
        userService := userservice.NewUserService(userRepo, a.cfg.HashingCost)

        regRepo := regrepo.NewRegRepository(a.DB)
        regService := regservice.NewRegService(regRepo, a.cfg.HashingCost)

        memberService := memberservice.NewMemberService(memberRepo, groupRepo, userRepo)

        apiV1 := router.Group("/api/v1")

        public := apiV1.Group("")
        </span><span class="cov0" title="0">{
                public.POST("/signup", reghandler.NewRegHandler(regService, a.l))
                public.POST("/auth/login", authhandler.NewLogInHandler(userRepo, a.l,
                        a.cfg.SecretToken, a.cfg.AccessDuration, a.cfg.RefreshDuration))
                public.POST("/auth/refresh", authhandler.NewRefreshTokenHandler(userRepo, a.l, a.cfg.SecretToken, a.cfg.AccessDuration))
        }</span>

        <span class="cov0" title="0">protected := apiV1.Group("")
        protected.Use(middleware.AuthMiddleware(userRepo, a.cfg.SecretToken))
        </span><span class="cov0" title="0">{
                protected.POST("/auth/logout", authhandler.NewLogOutHandler(a.l))

                groups := protected.Group("/groups")
                </span><span class="cov0" title="0">{
                        groups.POST("", grouphandler.NewCreateGroupHandler(groupService, a.l))
                        groups.GET("/:uuid", grouphandler.NewGetGroupHandler(groupService, a.l))
                        groups.GET("", grouphandler.NewGetAllGroupsHandler(groupService, a.l))
                        groups.PUT("/:uuid", grouphandler.NewUpdateGroupHandler(groupService, a.l))
                        groups.DELETE("/:uuid", grouphandler.NewDeleteGroupHandler(groupService, a.l))

                        members := groups.Group("/:uuid/members")
                        </span><span class="cov0" title="0">{
                                members.GET("", memberhandler.NewGetAllMembersHandler(memberService, a.l))
                                members.POST("", memberhandler.NewCreateMemberHandler(memberService, a.l))
                                members.PUT("/:user_uuid", memberhandler.NewUpdateMemberHandler(memberService, a.l))
                                members.DELETE("/:user_uuid", memberhandler.NewDeleteMemberHandler(memberService, a.l))
                        }</span>
                }

                <span class="cov0" title="0">documents := protected.Group("/documents")
                </span><span class="cov0" title="0">{
                        documents.POST("", documenthandler.NewCreateDocumentHandler(documentService, a.l))
                        documents.GET("/:uuid", documenthandler.NewGetDocumentHandler(documentService, a.l))
                        documents.GET("", documenthandler.NewGetAllDocumentsHandler(documentService, a.l))
                        documents.PUT("/:uuid", documenthandler.NewUpdateDocumentHandler(documentService, a.l))
                        documents.DELETE("/:uuid", documenthandler.NewDeleteDocumentHandler(documentService, a.l))
                }</span>

                <span class="cov0" title="0">users := protected.Group("/users")
                </span><span class="cov0" title="0">{
                        users.GET("/:uuid", userhandler.NewGetUserHandler(userService, a.l))
                        users.GET("", userhandler.NewGetAllUsersHandler(userService, a.l))
                        users.PUT("/:uuid", userhandler.NewUpdateUserHandler(userService, a.l))
                        users.DELETE("/:uuid", userhandler.NewDeleteUserHandler(userService, a.l))
                }</span>
        }
        <span class="cov0" title="0">return router</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"

        "github.com/kelseyhightower/envconfig"
)

type DBConfig struct {
        Driver string `envconfig:"DB_DRIVER" required:"true"`
        Host   string `envconfig:"DB_HOST" required:"true"`
        Port   string `envconfig:"DB_PORT" required:"true"`
        User   string `envconfig:"DB_USER" required:"true"`
        Pass   string `envconfig:"DB_PASSWORD" required:"true"`
        Name   string `envconfig:"DB_NAME" required:"true"`
}

func (c DBConfig) DSN() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
                c.Host, c.Port, c.User, c.Pass, c.Name,
        )
}</span>

type SrvConfig struct {
        Port string `envconfig:"API_PORT" required:"true"`
}

type CORSConfig struct {
        AllowOrigins     []string `envconfig:"CORS_ALLOW_ORIGINS" required:"true"`
        AllowMethods     []string `envconfig:"CORS_ALLOW_METHODS" required:"true"`
        AllowHeaders     []string `envconfig:"CORS_ALLOW_HEADERS" required:"true"`
        ExposeHeaders    []string `envconfig:"CORS_EXPOSE_HEADERS" required:"true"`
        AllowCredentials bool     `envconfig:"CORS_ALLOW_CREDENTIALS" required:"true"`
        MaxAge           int      `envconfig:"CORS_MAX_AGE" required:"true"`
}

type Config struct {
        DB              DBConfig
        Srv             SrvConfig
        CORS            CORSConfig
        HashingCost     int    `envconfig:"HASHING_COST" required:"true"`
        SecretToken     string `envconfig:"SECRET_TOKEN" required:"true"`
        AccessDuration  int    `envconfig:"ACCESS_DURATION" required:"true"`
        RefreshDuration int    `envconfig:"REFRESH_DURATION" required:"true"`
}

func Load() (*Config, error) <span class="cov0" title="0">{
        var cfg Config
        if err := envconfig.Process("", &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/auth/requests"
        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
)

type userRepository interface {
        GetByLogin(ctx context.Context, login string) (*domain.User, error)
        GetByUUID(ctx context.Context, uuid uuid.UUID) (*domain.User, error)
}

// NewLogInHandler handles user login and saves JWT tokens in cookies.
// @Summary User login
// @Description Authenticates user credentials, creates and saves JWT access/refresh tokens in cookies.
// @Tags auth
// @Accept json
// @Produce json
// @Param request body requests.LogInRequest true "User login request"
// @Success 200 {object} map[string]string "Login successful"
// @Failure 400 {object} map[string]string "Invalid request format"
// @Failure 401 {object} map[string]string "Invalid credentials"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /auth/login [post]
func NewLogInHandler(userRepo userRepository, logger *zap.Logger, secretToken string, accessDur, refreshDur int) gin.HandlerFunc <span class="cov10" title="6">{
        return func(c *gin.Context) </span><span class="cov10" title="6">{
                var req requests.LogInRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("log in handler: failed to bind request: %v", err)
                        logger.Error("failed to bind request", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request format"})
                        return
                }</span>
                <span class="cov9" title="5">if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("log in handler: validation failed: %v", err)
                        logger.Error("validation failed", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "validation failed", "details": err.Error()})
                        return
                }</span>

                <span class="cov9" title="5">user, err := userRepo.GetByLogin(c, req.Login)
                if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to log in", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to log in"})
                        return
                }</span>
                <span class="cov7" title="4">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to log in", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to log in"})
                        return
                }</span>

                <span class="cov6" title="3">if user == nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
                        return
                }</span>

                <span class="cov4" title="2">err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
                if err != nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
                        return
                }</span>

                <span class="cov1" title="1">if secretToken == "" </span><span class="cov0" title="0">{
                        logger.Error("server misconfiguration")
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "server misconfiguration"})
                        return
                }</span>

                <span class="cov1" title="1">accessExpTime := time.Now().Add(time.Duration(accessDur) * time.Minute)
                accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.RegisteredClaims{
                        Subject:   user.UUID.String(),
                        ExpiresAt: jwt.NewNumericDate(accessExpTime),
                })

                accessTokenString, err := accessToken.SignedString([]byte(secretToken))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to generate access token", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to generate access token"})
                        return
                }</span>

                <span class="cov1" title="1">refreshExpTime := time.Now().Add(time.Duration(refreshDur) * time.Minute)
                refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.RegisteredClaims{
                        Subject:   user.UUID.String(),
                        ExpiresAt: jwt.NewNumericDate(refreshExpTime),
                })

                refreshTokenString, err := refreshToken.SignedString([]byte(secretToken))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to generate refresh token", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to generate refresh token"})
                        return
                }</span>

                <span class="cov1" title="1">c.SetSameSite(http.SameSiteNoneMode)
                c.SetCookie("accessToken", accessTokenString, int(time.Until(accessExpTime).Seconds()), "/", "", true, true)
                c.SetCookie("refreshToken", refreshTokenString, int(time.Until(refreshExpTime).Seconds()), "/", "", true, true)

                c.JSON(http.StatusOK, gin.H{})</span>
        }
}

func Validate(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "I'm logged in",
        })
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// NewLogOutHandler logs the user out by expiring auth cookies.
// @Summary User logout
// @Description Expires the JWT access/refresh cookies.
// @Tags auth
// @Success 204 "Logged out successfully"
// @Router /auth/logout [post]
func NewLogOutHandler(logger *zap.Logger) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                c.SetSameSite(http.SameSiteNoneMode)
                c.SetCookie("accessToken", "", -1, "/", "", true, true)
                c.SetCookie("refreshToken", "", -1, "/", "", true, true)

                c.Status(http.StatusNoContent)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "go.uber.org/zap"
)

// NewRefreshTokenHandler handles refresh token requests
// @Summary Refresh access token
// @Description Validates the refresh token cookie and issues a new access/refresh token pair
// @Tags auth
// @Produce json
// @Param Cookie header string true "Cookie header containing refreshToken cookie"
// @Success 200 {object} map[string]string "Tokens refreshed successfully"
// @Failure 401 {object} map[string]string "Invalid or expired refresh token"
// @Failure 500 {object} map[string]string "Internal server error"
// @Router /auth/refresh [post]
func NewRefreshTokenHandler(userRepo userRepository, logger *zap.Logger, secretToken string, accessDur int) gin.HandlerFunc <span class="cov10" title="5">{
        return func(c *gin.Context) </span><span class="cov10" title="5">{
                // var req requests.RefreshTokenRequest
                // if err := c.ShouldBindJSON(&amp;req); err != nil {
                //         err = fmt.Errorf("refresh token handler: failed to bind request: %v", err)
                //         logger.Error("failed to bind request", zap.Error(err))
                //         c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request format"})
                //         return
                // }

                tokenString, err := c.Cookie("refreshToken")
                if err != nil || tokenString == "" </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "refresh token required"})
                        return
                }</span>

                <span class="cov8" title="4">if secretToken == "" </span><span class="cov1" title="1">{
                        logger.Error("server misconfiguration")
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "server misconfiguration"})
                        return
                }</span>

                <span class="cov7" title="3">token, err := jwt.ParseWithClaims(tokenString, &amp;jwt.RegisteredClaims{}, func(t *jwt.Token) (interface{}, error) </span><span class="cov4" title="2">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov4" title="2">return []byte(secretToken), nil</span>
                })
                <span class="cov7" title="3">if err != nil </span><span class="cov4" title="2">{
                        logger.Error("invalid refresh token", zap.Error(err))
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid refresh token"})
                        return
                }</span>

                <span class="cov1" title="1">claims, ok := token.Claims.(*jwt.RegisteredClaims)
                if !ok || !token.Valid </span><span class="cov0" title="0">{
                        logger.Error("invalid refresh token claims")
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid refresh token claims"})
                        return
                }</span>

                <span class="cov1" title="1">if claims.ExpiresAt != nil &amp;&amp; time.Now().After(claims.ExpiresAt.Time) </span><span class="cov0" title="0">{
                        logger.Error("refresh token expired")
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "refresh token expired"})
                        return
                }</span>

                <span class="cov1" title="1">uid, err := uuid.Parse(claims.Subject)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("invalid uuid format in refresh token", zap.Error(err))
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid uuid format in refresh token"})
                        return
                }</span>

                <span class="cov1" title="1">user, err := userRepo.GetByUUID(c.Request.Context(), uid)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, domain.ErrInternal) </span><span class="cov0" title="0">{
                                logger.Error("failed to fetch user from refresh token", zap.Error(err))
                                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to fetch user from refresh token"})
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Error("invalid refresh token", zap.Error(err))
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid refresh token"})
                        return</span>
                }

                <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid refresh token"})
                        return
                }</span>

                <span class="cov1" title="1">accessTokenExpTime := time.Now().Add(time.Duration(accessDur) * time.Minute)
                accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.RegisteredClaims{
                        Subject:   user.UUID.String(),
                        ExpiresAt: jwt.NewNumericDate(accessTokenExpTime),
                })

                accessTokenString, err := accessToken.SignedString([]byte(secretToken))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to generate access token", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to generate access token"})
                        return
                }</span>

                <span class="cov1" title="1">refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.RegisteredClaims{
                        Subject:   user.UUID.String(),
                        ExpiresAt: claims.ExpiresAt,
                })

                refreshTokenString, err := refreshToken.SignedString([]byte(secretToken))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to generate refresh token", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to generate refresh token"})
                        return
                }</span>

                <span class="cov1" title="1">c.SetSameSite(http.SameSiteNoneMode)
                c.SetCookie("accessToken", accessTokenString, int(time.Until(accessTokenExpTime).Seconds()), "/", "", true, true)
                c.SetCookie("refreshToken", refreshTokenString, int(time.Until(claims.ExpiresAt.Time).Seconds()), "/", "", true, true)

                c.JSON(http.StatusOK, gin.H{})</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package requests

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
)

type LogInRequest struct {
        Login    string `json:"login"`
        Password string `json:"password"`
}

func (r LogInRequest) Validate() error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.Login, validation.Required, validation.Length(1, 255)),
                validation.Field(&amp;r.Password, validation.Required, validation.Length(1, 255)),
        )
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package document

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/requests"
        "go.uber.org/zap"
)

type createDocumentService interface {
        Create(ctx context.Context, groupUUID uuid.UUID, name, content string) (*domain.Document, error)
}

// NewCreateDocumentHandler creates a new document
// @Summary Create a new document
// @Description Create a new document with the provided group UUID, name and content
// @Tags documents
// @Accept json
// @Produce json
// @Param request body requests.CreateDocumentRequest true "Document creation request"
// @Success 201 {object} responses.CreateDocumentResponse "Document created successfully"
// @Failure 400 {object} map[string]interface{} "Invalid request format or validation failed"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /documents [post]
func NewCreateDocumentHandler(service createDocumentService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="6">{
        return func(c *gin.Context) </span><span class="cov10" title="6">{
                var req requests.CreateDocumentRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov4" title="2">{
                        err = fmt.Errorf("create document handler: failed to bind request: %v", err)
                        logger.Error("failed to bind request", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request format"})
                        return
                }</span>

                <span class="cov7" title="4">if err := req.Validate(); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("create document handler: validation failed: %v", err)
                        logger.Error("validation failed", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "validation failed", "details": err.Error()})
                        return
                }</span>

                <span class="cov6" title="3">document, err := service.Create(c, req.GroupUUID, req.Name, req.Content)
                if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to create document",
                                zap.Error(err),
                                zap.String("group_uuid", req.GroupUUID.String()),
                                zap.String("name", req.Name),
                        )
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create document"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to create document",
                                zap.Error(err),
                                zap.String("group_uuid", req.GroupUUID.String()),
                                zap.String("name", req.Name),
                        )
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create document"})
                        return
                }</span>

                <span class="cov1" title="1">response := mapDocumentToCreateResponse(document)

                c.JSON(http.StatusCreated, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package document

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/responses"
        "go.uber.org/zap"
)

type deleteDocumentService interface {
        Delete(ctx context.Context, uuid uuid.UUID) error
}

// NewDeleteDocumentHandler deletes a document by UUID
// @Summary Delete a document by UUID
// @Description Delete a specific document by its UUID
// @Tags documents
// @Accept json
// @Produce json
// @Param uuid path string true "Document UUID"
// @Success 200 {object} responses.DeleteDocumentResponse "Document deleted successfully"
// @Failure 400 {object} map[string]interface{} "Invalid UUID format"
// @Failure 404 {object} map[string]interface{} "Document not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /documents/{uuid} [delete]
func NewDeleteDocumentHandler(service deleteDocumentService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="5">{
        return func(c *gin.Context) </span><span class="cov10" title="5">{
                uuidParam := c.Param("uuid")
                parsedUUID, err := uuid.Parse(uuidParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("delete document handler: failed to parse uuid: %v", err)
                        logger.Error("failed to parse uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid uuid format"})
                        return
                }</span>

                <span class="cov8" title="4">err = service.Delete(c, parsedUUID)
                if errors.Is(err, domain.ErrDocumentNotFound) </span><span class="cov1" title="1">{
                        logger.Warn("document not found", zap.String("uuid", uuidParam))
                        c.JSON(http.StatusNotFound, gin.H{"error": "document not found"})
                        return
                }</span>
                <span class="cov7" title="3">if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to delete document", zap.Error(err), zap.String("uuid", uuidParam))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete document"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to delete document", zap.Error(err), zap.String("uuid", uuidParam))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete document"})
                        return
                }</span>

                <span class="cov1" title="1">response := responses.DeleteDocumentResponse{
                        Message: "Document deleted successfully",
                }

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package document

import (
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/responses"
)

func mapDocumentToCreateResponse(document *domain.Document) responses.CreateDocumentResponse <span class="cov1" title="1">{
        return responses.CreateDocumentResponse{
                UUID:      document.UUID,
                GroupUUID: document.GroupUUID,
                Name:      document.Name,
                Content:   document.Content,
                CreatedAt: document.CreatedAt,
        }
}</span>

func mapDocumentToGetResponse(document *domain.Document) responses.GetDocumentResponse <span class="cov10" title="3">{
        return responses.GetDocumentResponse{
                UUID:      document.UUID,
                GroupUUID: document.GroupUUID,
                Name:      document.Name,
                Content:   document.Content,
                CreatedAt: document.CreatedAt,
        }
}</span>

func mapDocumentToUpdateResponse(document *domain.Document) responses.UpdateDocumentResponse <span class="cov1" title="1">{
        return responses.UpdateDocumentResponse{
                UUID:      document.UUID,
                GroupUUID: document.GroupUUID,
                Name:      document.Name,
                Content:   document.Content,
                CreatedAt: document.CreatedAt,
        }
}</span>

func mapDocumentsToGetAllResponse(documents []*domain.Document) []responses.GetDocumentResponse <span class="cov6" title="2">{
        result := make([]responses.GetDocumentResponse, len(documents))
        for i, document := range documents </span><span class="cov6" title="2">{
                result[i] = mapDocumentToGetResponse(document)
        }</span>
        <span class="cov6" title="2">return result</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package document

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/responses"
        "go.uber.org/zap"
)

type getDocumentService interface {
        GetByUUIDForUser(ctx context.Context, documentUUID, userUUID uuid.UUID) (*domain.Document, error)
}

type getAllDocumentsService interface {
        GetAllForUser(ctx context.Context, userUUID uuid.UUID) ([]*domain.Document, error)
}

// NewGetDocumentHandler retrieves a document by UUID
// @Summary Get a document by UUID
// @Description Retrieve a specific document by its UUID if the requesting user is a member of the owning group
// @Tags documents
// @Accept json
// @Produce json
// @Param uuid path string true "Document UUID"
// @Success 200 {object} responses.GetDocumentResponse "Document retrieved successfully"
// @Failure 400 {object} map[string]interface{} "Invalid UUID format"
// @Failure 401 {object} map[string]interface{} "Authentication required"
// @Failure 403 {object} map[string]interface{} "Access forbidden"
// @Failure 404 {object} map[string]interface{} "Document not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /documents/{uuid} [get]
func NewGetDocumentHandler(service getDocumentService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="7">{
        return func(c *gin.Context) </span><span class="cov10" title="7">{
                userUUIDValue, exists := c.Get("user_uid")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "user context missing"})
                        return
                }</span>

                <span class="cov9" title="6">userUUID, ok := userUUIDValue.(uuid.UUID)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user context"})
                        return
                }</span>

                <span class="cov9" title="6">uuidParam := c.Param("uuid")
                parsedUUID, err := uuid.Parse(uuidParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("get document handler: failed to parse uuid: %v", err)
                        logger.Error("failed to parse uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid uuid format"})
                        return
                }</span>

                <span class="cov8" title="5">document, err := service.GetByUUIDForUser(c, parsedUUID, userUUID)
                if errors.Is(err, domain.ErrDocumentNotFound) </span><span class="cov1" title="1">{
                        logger.Warn("document not found", zap.String("uuid", uuidParam))
                        c.JSON(http.StatusNotFound, gin.H{"error": "document not found"})
                        return
                }</span>
                <span class="cov7" title="4">if errors.Is(err, domain.ErrForbidden) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "access forbidden"})
                        return
                }</span>
                <span class="cov6" title="3">if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to get document", zap.Error(err), zap.String("uuid", uuidParam))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get document"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to get document", zap.Error(err), zap.String("uuid", uuidParam))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get document"})
                        return
                }</span>

                <span class="cov1" title="1">response := mapDocumentToGetResponse(document)

                c.JSON(http.StatusOK, response)</span>
        }
}

// NewGetAllDocumentsHandler retrieves all documents
// @Summary Get all documents
// @Description Retrieve a list of all documents belonging to groups the requesting user is a member of
// @Tags documents
// @Accept json
// @Produce json
// @Success 200 {object} responses.GetAllDocumentsResponse "Documents retrieved successfully"
// @Failure 401 {object} map[string]interface{} "Authentication required"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /documents [get]
func NewGetAllDocumentsHandler(service getAllDocumentsService, logger *zap.Logger) gin.HandlerFunc <span class="cov8" title="5">{
        return func(c *gin.Context) </span><span class="cov8" title="5">{
                userUUIDValue, exists := c.Get("user_uid")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "user context missing"})
                        return
                }</span>

                <span class="cov7" title="4">userUUID, ok := userUUIDValue.(uuid.UUID)
                if !ok </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid user context"})
                        return
                }</span>

                <span class="cov7" title="4">documents, err := service.GetAllForUser(c, userUUID)
                if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to get documents", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get documents"})
                        return
                }</span>
                <span class="cov6" title="3">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to get documents", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get documents"})
                        return
                }</span>

                <span class="cov4" title="2">response := responses.GetAllDocumentsResponse{
                        Documents: mapDocumentsToGetAllResponse(documents),
                }

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package requests

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/google/uuid"
)

type CreateDocumentRequest struct {
        GroupUUID uuid.UUID `json:"group_uuid"`
        Name      string    `json:"name"`
        Content   string    `json:"content"`
}

func (r CreateDocumentRequest) Validate() error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.GroupUUID, validation.Required),
                validation.Field(&amp;r.Name, validation.Required, validation.Length(1, 255)),
                validation.Field(&amp;r.Content, validation.Required),
        )
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package requests

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
)

type UpdateDocumentRequest struct {
        Name    string `json:"name"`
        Content string `json:"content"`
}

func (r UpdateDocumentRequest) Validate() error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.Name, validation.Required, validation.Length(1, 255)),
                validation.Field(&amp;r.Content, validation.Required),
        )
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package document

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/document/requests"
        "go.uber.org/zap"
)

type updateDocumentService interface {
        Update(ctx context.Context, uuid uuid.UUID, name, content string) (*domain.Document, error)
}

// NewUpdateDocumentHandler updates a document by UUID
// @Summary Update a document by UUID
// @Description Update a specific document's name and content by its UUID
// @Tags documents
// @Accept json
// @Produce json
// @Param uuid path string true "Document UUID"
// @Param request body requests.UpdateDocumentRequest true "Document update request"
// @Success 200 {object} responses.UpdateDocumentResponse "Document updated successfully"
// @Failure 400 {object} map[string]interface{} "Invalid UUID format or validation failed"
// @Failure 404 {object} map[string]interface{} "Document not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /documents/{uuid} [put]
func NewUpdateDocumentHandler(service updateDocumentService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="7">{
        return func(c *gin.Context) </span><span class="cov10" title="7">{
                uuidParam := c.Param("uuid")
                parsedUUID, err := uuid.Parse(uuidParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update document handler: failed to parse uuid: %v", err)
                        logger.Error("failed to parse uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid uuid format"})
                        return
                }</span>

                <span class="cov9" title="6">var req requests.UpdateDocumentRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update document handler: failed to bind request: %v", err)
                        logger.Error("failed to bind request", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request format"})
                        return
                }</span>

                <span class="cov8" title="5">if err := req.Validate(); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update document handler: validation failed: %v", err)
                        logger.Error("validation failed", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "validation failed", "details": err.Error()})
                        return
                }</span>

                <span class="cov7" title="4">document, err := service.Update(c, parsedUUID, req.Name, req.Content)
                if errors.Is(err, domain.ErrDocumentNotFound) </span><span class="cov1" title="1">{
                        logger.Warn("document not found", zap.String("uuid", uuidParam))
                        c.JSON(http.StatusNotFound, gin.H{"error": "document not found"})
                        return
                }</span>
                <span class="cov6" title="3">if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to update document",
                                zap.Error(err),
                                zap.String("uuid", uuidParam),
                        )
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update document"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to update document",
                                zap.Error(err),
                                zap.String("uuid", uuidParam),
                        )
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update document"})
                        return
                }</span>

                <span class="cov1" title="1">response := mapDocumentToUpdateResponse(document)

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package group

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/requests"
        "go.uber.org/zap"
)

type createGroupService interface {
        Create(ctx context.Context, ownerUUID uuid.UUID, name string) (*domain.Group, error)
}

// NewCreateGroupHandler creates a new group
// @Summary Create a new group
// @Description Create a new group with the provided name
// @Tags groups
// @Accept json
// @Produce json
// @Param request body requests.CreateGroupRequest true "Group creation request"
// @Success 201 {object} responses.CreateGroupResponse "Group created successfully"
// @Failure 400 {object} map[string]interface{} "Invalid request format or validation failed"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /groups [post]
func NewCreateGroupHandler(service createGroupService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="5">{
        return func(c *gin.Context) </span><span class="cov10" title="5">{
                userUUIDValue, exists := c.Get("user_uid")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "user context missing"})
                        return
                }</span>

                <span class="cov10" title="5">userUUID, ok := userUUIDValue.(uuid.UUID)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user context"})
                        return
                }</span>

                <span class="cov10" title="5">var req requests.CreateGroupRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("create group handler: failed to bind request: %v", err)
                        logger.Error("failed to bind request", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request format"})
                        return
                }</span>

                <span class="cov8" title="4">if err := req.Validate(); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("create group handler: validation failed: %v", err)
                        logger.Error("validation failed", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "validation failed", "details": err.Error()})
                        return
                }</span>

                <span class="cov7" title="3">group, err := service.Create(c, userUUID, req.Name)
                if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to create group", zap.Error(err), zap.String("name", req.Name))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create group"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to create group", zap.Error(err), zap.String("name", req.Name))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create group"})
                        return
                }</span>

                <span class="cov1" title="1">response := mapGroupToCreateResponse(group)

                c.JSON(http.StatusCreated, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package group

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/responses"
        "go.uber.org/zap"
)

type deleteGroupService interface {
        Delete(ctx context.Context, uuid uuid.UUID) error
}

// NewDeleteGroupHandler deletes a group by UUID
// @Summary Delete a group by UUID
// @Description Delete a specific group by its UUID
// @Tags groups
// @Accept json
// @Produce json
// @Param uuid path string true "Group UUID"
// @Success 200 {object} responses.DeleteGroupResponse "Group deleted successfully"
// @Failure 400 {object} map[string]interface{} "Invalid UUID format"
// @Failure 404 {object} map[string]interface{} "Group not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /groups/{uuid} [delete]
func NewDeleteGroupHandler(service deleteGroupService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="5">{
        return func(c *gin.Context) </span><span class="cov10" title="5">{
                uuidParam := c.Param("uuid")
                parsedUUID, err := uuid.Parse(uuidParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("delete group handler: failed to parse uuid: %v", err)
                        logger.Error("failed to parse uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid uuid format"})
                        return
                }</span>

                <span class="cov8" title="4">err = service.Delete(c, parsedUUID)
                if errors.Is(err, domain.ErrGroupNotFound) </span><span class="cov1" title="1">{
                        logger.Warn("group not found", zap.String("uuid", uuidParam))
                        c.JSON(http.StatusNotFound, gin.H{"error": "group not found"})
                        return
                }</span>
                <span class="cov7" title="3">if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to delete group", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete group"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to delete group", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete group"})
                        return
                }</span>

                <span class="cov1" title="1">response := responses.DeleteGroupResponse{
                        Message: "Group deleted successfully",
                }

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package group

import (
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/responses"
)

func mapGroupToCreateResponse(group *domain.Group) responses.CreateGroupResponse <span class="cov1" title="1">{
        return responses.CreateGroupResponse{
                UUID:      group.UUID,
                Name:      group.Name,
                CreatedAt: group.CreatedAt,
        }
}</span>

func mapGroupToGetResponse(group *domain.Group) responses.GetGroupResponse <span class="cov10" title="3">{
        return responses.GetGroupResponse{
                UUID:      group.UUID,
                Name:      group.Name,
                CreatedAt: group.CreatedAt,
        }
}</span>

func mapGroupToUpdateResponse(group *domain.Group) responses.UpdateGroupResponse <span class="cov1" title="1">{
        return responses.UpdateGroupResponse{
                UUID:      group.UUID,
                Name:      group.Name,
                CreatedAt: group.CreatedAt,
        }
}</span>

func mapGroupsToGetAllResponse(groups []*domain.Group) []responses.GetGroupResponse <span class="cov6" title="2">{
        result := make([]responses.GetGroupResponse, len(groups))
        for i, group := range groups </span><span class="cov6" title="2">{
                result[i] = mapGroupToGetResponse(group)
        }</span>
        <span class="cov6" title="2">return result</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package group

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/responses"
        "go.uber.org/zap"
)

type getGroupService interface {
        GetByUUIDForUser(ctx context.Context, groupUUID, userUUID uuid.UUID) (*domain.Group, error)
}

type getAllGroupsService interface {
        GetAllForUser(ctx context.Context, userUUID uuid.UUID) ([]*domain.Group, error)
}

// NewGetGroupHandler retrieves a group by UUID
// @Summary Get a group by UUID
// @Description Retrieve a specific group by its UUID if the requesting user is a member
// @Tags groups
// @Accept json
// @Produce json
// @Param uuid path string true "Group UUID"
// @Success 200 {object} responses.GetGroupResponse "Group retrieved successfully"
// @Failure 400 {object} map[string]interface{} "Invalid UUID format"
// @Failure 401 {object} map[string]interface{} "Authentication required"
// @Failure 403 {object} map[string]interface{} "Access forbidden"
// @Failure 404 {object} map[string]interface{} "Group not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /groups/{uuid} [get]
func NewGetGroupHandler(service getGroupService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="8">{
        return func(c *gin.Context) </span><span class="cov10" title="8">{
                userUUIDValue, exists := c.Get("user_uid")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "user context missing"})
                        return
                }</span>
                <span class="cov9" title="7">userUUID, ok := userUUIDValue.(uuid.UUID)
                if !ok </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user context"})
                        return
                }</span>

                <span class="cov8" title="6">uuidParam := c.Param("uuid")
                parsedUUID, err := uuid.Parse(uuidParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("get group handler: failed to parse uuid: %v", err)
                        logger.Error("failed to parse uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid uuid format"})
                        return
                }</span>

                <span class="cov7" title="5">group, err := service.GetByUUIDForUser(c, parsedUUID, userUUID)
                if errors.Is(err, domain.ErrGroupNotFound) </span><span class="cov1" title="1">{
                        logger.Warn("group not found", zap.String("uuid", uuidParam))
                        c.JSON(http.StatusNotFound, gin.H{"error": "group not found"})
                        return
                }</span>
                <span class="cov7" title="4">if errors.Is(err, domain.ErrForbidden) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "access forbidden"})
                        return
                }</span>
                <span class="cov5" title="3">if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get group"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to get group", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get group"})
                        return
                }</span>

                <span class="cov1" title="1">response := mapGroupToGetResponse(group)

                c.JSON(http.StatusOK, response)</span>
        }
}

// NewGetAllGroupsHandler retrieves all groups
// @Summary Get all groups
// @Description Retrieve a list of all groups the requesting user belongs to
// @Tags groups
// @Accept json
// @Produce json
// @Success 200 {object} responses.GetAllGroupsResponse "Groups retrieved successfully"
// @Failure 401 {object} map[string]interface{} "Authentication required"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /groups [get]
func NewGetAllGroupsHandler(service getAllGroupsService, logger *zap.Logger) gin.HandlerFunc <span class="cov8" title="6">{
        return func(c *gin.Context) </span><span class="cov8" title="6">{
                userUUIDValue, exists := c.Get("user_uid")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "user context missing"})
                        return
                }</span>

                <span class="cov7" title="5">userUUID, ok := userUUIDValue.(uuid.UUID)
                if !ok </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid user context"})
                        return
                }</span>

                <span class="cov7" title="4">groups, err := service.GetAllForUser(c, userUUID)
                if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to get groups", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get groups"})
                        return
                }</span>
                <span class="cov5" title="3">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to get groups", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get groups"})
                        return
                }</span>

                <span class="cov4" title="2">response := responses.GetAllGroupsResponse{
                        Groups: mapGroupsToGetAllResponse(groups),
                }

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package requests

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
)

type CreateGroupRequest struct {
        Name string `json:"name"`
}

func (r CreateGroupRequest) Validate() error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.Name, validation.Required, validation.Length(1, 255)),
        )
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package requests

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
)

type UpdateGroupRequest struct {
        Name string `json:"name"`
}

func (r UpdateGroupRequest) Validate() error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.Name, validation.Required, validation.Length(1, 255)),
        )
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package group

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/group/requests"
        "go.uber.org/zap"
)

type updateGroupService interface {
        Update(ctx context.Context, uuid uuid.UUID, name string) (*domain.Group, error)
}

// NewUpdateGroupHandler updates a group by UUID
// @Summary Update a group by UUID
// @Description Update a specific group's name by its UUID
// @Tags groups
// @Accept json
// @Produce json
// @Param uuid path string true "Group UUID"
// @Param request body requests.UpdateGroupRequest true "Group update request"
// @Success 200 {object} responses.UpdateGroupResponse "Group updated successfully"
// @Failure 400 {object} map[string]interface{} "Invalid UUID format or validation failed"
// @Failure 404 {object} map[string]interface{} "Group not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /groups/{uuid} [put]
func NewUpdateGroupHandler(service updateGroupService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="7">{
        return func(c *gin.Context) </span><span class="cov10" title="7">{
                uuidParam := c.Param("uuid")
                parsedUUID, err := uuid.Parse(uuidParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update group handler: failed to parse uuid: %v", err)
                        logger.Error("failed to parse uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid uuid format"})
                        return
                }</span>

                <span class="cov9" title="6">var req requests.UpdateGroupRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update group handler: failed to bind request: %v", err)
                        logger.Error("failed to bind request", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request format"})
                        return
                }</span>

                <span class="cov8" title="5">if err := req.Validate(); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update group handler: validation failed: %v", err)
                        logger.Error("validation failed", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "validation failed", "details": err.Error()})
                        return
                }</span>

                <span class="cov7" title="4">group, err := service.Update(c, parsedUUID, req.Name)
                if errors.Is(err, domain.ErrGroupNotFound) </span><span class="cov1" title="1">{
                        logger.Warn("group not found", zap.String("uuid", uuidParam))
                        c.JSON(http.StatusNotFound, gin.H{"error": "group not found"})
                        return
                }</span>
                <span class="cov6" title="3">if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to update group", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update group"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to update group", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update group"})
                        return
                }</span>

                <span class="cov1" title="1">response := mapGroupToUpdateResponse(group)

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package member

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/requests"
        "go.uber.org/zap"
)

type createMemberService interface {
        CreateMemberByUser(ctx context.Context, userUUID, groupUUID, memberUUID uuid.UUID,
                role string) (*domain.Member, error)
}

func NewCreateMemberHandler(service createMemberService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="12">{
        return func(c *gin.Context) </span><span class="cov10" title="12">{
                groupUUIDParam := c.Param("uuid")
                groupUUID, err := uuid.Parse(groupUUIDParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("create member handler: failed to parse group uuid: %w", err)
                        logger.Error("failed to parse group uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid group uuid format"})
                        return
                }</span>

                <span class="cov9" title="11">userUUIDValue, exists := c.Get("user_uid")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "user context missing"})
                        return
                }</span>

                <span class="cov9" title="10">userUUID, ok := userUUIDValue.(uuid.UUID)
                if !ok </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user context"})
                        return
                }</span>

                <span class="cov8" title="9">var req requests.CreateMemberRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("create member handler: failed to bind request: %w", err)
                        logger.Error("failed to bind request", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request format"})
                        return
                }</span>

                <span class="cov8" title="8">if err := req.Validate(); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("create member handler: validation failed: %w", err)
                        logger.Error("validation failed", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "validation failed", "details": err.Error()})
                        return
                }</span>

                <span class="cov8" title="7">member, err := service.CreateMemberByUser(c.Request.Context(),
                        userUUID, groupUUID, req.UserUUID, req.Role)
                if errors.Is(err, domain.ErrForbidden) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "access forbidden"})
                        return
                }</span>
                <span class="cov7" title="6">if errors.Is(err, domain.ErrGroupNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "group not found"})
                        return
                }</span>
                <span class="cov6" title="5">if errors.Is(err, domain.ErrUserNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov6" title="4">if errors.Is(err, domain.ErrAlreadyExists) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusConflict, gin.H{"error": "member already exists"})
                        return
                }</span>
                <span class="cov4" title="3">if errors.Is(err, domain.ErrOnlyAuthor) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "there must be only one author"})
                        return
                }</span>
                <span class="cov3" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to create member", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create member"})
                        return
                }</span>

                <span class="cov1" title="1">response := mapMemberToResponse(member)

                c.JSON(http.StatusCreated, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package member

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/responses"
        "go.uber.org/zap"
)

type deleteMemberService interface {
        DeleteMemberByUser(ctx context.Context, userUUID, groupUUID, memberUUID uuid.UUID) error
}

func NewDeleteMemberHandler(service deleteMemberService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="10">{
        return func(c *gin.Context) </span><span class="cov10" title="10">{
                groupUUIDParam := c.Param("uuid")
                groupUUID, err := uuid.Parse(groupUUIDParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("delete member handler: failed to parse group uuid: %w", err)
                        logger.Error("failed to parse group uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid group uuid format"})
                        return
                }</span>

                <span class="cov9" title="9">userUUIDValue, exists := c.Get("user_uid")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "user context missing"})
                        return
                }</span>

                <span class="cov9" title="8">userUUID, ok := userUUIDValue.(uuid.UUID)
                if !ok </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user context"})
                        return
                }</span>

                <span class="cov8" title="7">memberUUIDParam := c.Param("user_uuid")
                memberUUID, err := uuid.Parse(memberUUIDParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("delete member handler: failed to parse user uuid: %w", err)
                        logger.Error("failed to parse user uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user uuid format"})
                        return
                }</span>

                <span class="cov8" title="6">err = service.DeleteMemberByUser(c.Request.Context(), userUUID, groupUUID, memberUUID)
                if errors.Is(err, domain.ErrForbidden) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "access forbidden"})
                        return
                }</span>
                <span class="cov7" title="5">if errors.Is(err, domain.ErrGroupNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "group not found"})
                        return
                }</span>
                <span class="cov6" title="4">if errors.Is(err, domain.ErrUserNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "member not found"})
                        return
                }</span>
                <span class="cov5" title="3">if errors.Is(err, domain.ErrOnlyAuthor) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "cannot remove the last author"})
                        return
                }</span>
                <span class="cov3" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to remove group member", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to remove member"})
                        return
                }</span>

                <span class="cov1" title="1">response := responses.DeleteMemberResponse{
                        Message: "Member deleted successfully",
                }

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package member

import (
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/responses"
)

func mapMemberToResponse(member *domain.Member) responses.GetMemberResponse <span class="cov10" title="4">{
        return responses.GetMemberResponse{
                GroupUUID: member.GroupUUID,
                UserUUID:  member.UserUUID,
                Role:      member.Role,
                CreatedAt: member.CreatedAt,
        }
}</span>

func mapMembersToResponse(members []*domain.Member) []responses.GetMemberResponse <span class="cov1" title="1">{
        result := make([]responses.GetMemberResponse, len(members))
        for i, member := range members </span><span class="cov5" title="2">{
                result[i] = mapMemberToResponse(member)
        }</span>
        <span class="cov1" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package member

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/responses"
        "go.uber.org/zap"
)

type getAllMembersService interface {
        GetAllMembersForUser(ctx context.Context, userUUID, groupUUID uuid.UUID) ([]*domain.Member, error)
}

func NewGetAllMembersHandler(service getAllMembersService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="7">{
        return func(c *gin.Context) </span><span class="cov10" title="7">{
                groupUUIDParam := c.Param("uuid")
                groupUUID, err := uuid.Parse(groupUUIDParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("get all members handler: failed to parse uuid: %w", err)
                        logger.Error("failed to parse uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid uuid format"})
                        return
                }</span>

                <span class="cov9" title="6">userUUIDValue, exists := c.Get("user_uid")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "user context missing"})
                        return
                }</span>

                <span class="cov8" title="5">userUUID, ok := userUUIDValue.(uuid.UUID)
                if !ok </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user context"})
                        return
                }</span>

                <span class="cov7" title="4">members, err := service.GetAllMembersForUser(c.Request.Context(), userUUID, groupUUID)
                if errors.Is(err, domain.ErrForbidden) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "access forbidden"})
                        return
                }</span>
                <span class="cov6" title="3">if errors.Is(err, domain.ErrGroupNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "group not found"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to list group members", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list members"})
                        return
                }</span>

                <span class="cov1" title="1">response := responses.GetAllMembersResponse{
                        Members: mapMembersToResponse(members),
                }

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package requests

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

type CreateMemberRequest struct {
        UserUUID uuid.UUID `json:"user_uuid"`
        Role     string    `json:"role"`
}

func (r CreateMemberRequest) Validate() error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.UserUUID, validation.Required),
                validation.Field(&amp;r.Role, validation.Required, validation.Length(1, 50),
                        validation.In(
                                domain.RoleAuthor,
                                domain.RoleEditor,
                                domain.RoleViewer,
                        ),
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package requests

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

type UpdateMemberRequest struct {
        Role string `json:"role"`
}

func (r UpdateMemberRequest) Validate() error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.Role, validation.Required, validation.Length(1, 50),
                        validation.In(
                                domain.RoleAuthor,
                                domain.RoleEditor,
                                domain.RoleViewer,
                        )),
        )
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package member

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/member/requests"
        "go.uber.org/zap"
)

type updateMemberService interface {
        UpdateMemberByUser(ctx context.Context, userUUID, groupUUID, memberUUID uuid.UUID, role string) (*domain.Member, error)
}

func NewUpdateMemberHandler(service updateMemberService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="12">{
        return func(c *gin.Context) </span><span class="cov10" title="12">{
                groupUUIDParam := c.Param("uuid")
                groupUUID, err := uuid.Parse(groupUUIDParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update member handler: failed to parse group uuid: %w", err)
                        logger.Error("failed to parse group uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid group uuid format"})
                        return
                }</span>

                <span class="cov9" title="11">userUUIDValue, exists := c.Get("user_uid")
                if !exists </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "user context missing"})
                        return
                }</span>

                <span class="cov9" title="10">userUUID, ok := userUUIDValue.(uuid.UUID)
                if !ok </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user context"})
                        return
                }</span>

                <span class="cov8" title="9">memberUUIDParam := c.Param("user_uuid")
                memberUUID, err := uuid.Parse(memberUUIDParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update member handler: failed to parse user uuid: %w", err)
                        logger.Error("failed to parse user uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user uuid format"})
                        return
                }</span>

                <span class="cov8" title="8">var req requests.UpdateMemberRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update member handler: failed to bind request: %w", err)
                        logger.Error("failed to bind request", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request format"})
                        return
                }</span>

                <span class="cov8" title="7">if err := req.Validate(); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update member handler: validation failed: %w", err)
                        logger.Error("validation failed", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "validation failed", "details": err.Error()})
                        return
                }</span>

                <span class="cov7" title="6">member, err := service.UpdateMemberByUser(c.Request.Context(),
                        userUUID, groupUUID, memberUUID, req.Role)
                if errors.Is(err, domain.ErrForbidden) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "access forbidden"})
                        return
                }</span>
                <span class="cov6" title="5">if errors.Is(err, domain.ErrGroupNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "group not found"})
                        return
                }</span>
                <span class="cov6" title="4">if errors.Is(err, domain.ErrUserNotFound) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "member not found"})
                        return
                }</span>
                <span class="cov4" title="3">if errors.Is(err, domain.ErrOnlyAuthor) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "there must be an author"})
                        return
                }</span>
                <span class="cov3" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to update member role", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update member"})
                        return
                }</span>

                <span class="cov1" title="1">response := mapMemberToResponse(member)

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package reg

import (
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/reg/responses"
)

func mapUserToRegResponse(user *domain.User) responses.RegResponse <span class="cov8" title="1">{
        return responses.RegResponse{
                UUID:      user.UUID,
                Login:     user.Login,
                Email:     user.Email,
                CreatedAt: user.CreatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package reg

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/reg/requests"
        "go.uber.org/zap"
)

type regService interface {
        Register(ctx context.Context, login string, email string, password string) (*domain.User, error)
}

// NewRegHandler registers a new user
// @Summary Register a new user
// @Description Register a new user with the provided login, email and password
// @Tags registration
// @Accept json
// @Produce json
// @Param request body requests.RegRequest true "User registration request"
// @Success 201 {object} responses.RegResponse "User registered successfully"
// @Failure 400 {object} map[string]interface{} "Invalid request format or validation failed"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /signup [post]
func NewRegHandler(service regService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="6">{
        return func(c *gin.Context) </span><span class="cov10" title="6">{
                var req requests.RegRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov4" title="2">{
                        err = fmt.Errorf("register handler: failed to bind request: %v", err)
                        logger.Error("failed to bind request", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request format"})
                        return
                }</span>

                <span class="cov7" title="4">if err := req.Validate(); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("register handler: validation failed: %v", err)
                        logger.Error("validation failed", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "validation failed", "details": err.Error()})
                        return
                }</span>

                <span class="cov6" title="3">user, err := service.Register(c, req.Login, req.Email, req.Password)
                if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to register",
                                zap.Error(err),
                                zap.String("login", req.Login),
                                zap.String("email", req.Email),
                        )
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to register"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to register",
                                zap.Error(err),
                                zap.String("login", req.Login),
                                zap.String("email", req.Email),
                        )
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to register"})
                        return
                }</span>

                <span class="cov1" title="1">response := mapUserToRegResponse(user)

                c.JSON(http.StatusCreated, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package requests

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
)

type RegRequest struct {
        Login    string `json:"login"`
        Email    string `json:"email"`
        Password string `json:"password"`
}

func (r RegRequest) Validate() error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.Login, validation.Required, validation.Length(1, 255)),
                validation.Field(&amp;r.Email, validation.Required, validation.Length(1, 255)),
                validation.Field(&amp;r.Password, validation.Required, validation.Length(1, 255)),
        )
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package user

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/user/responses"
        "go.uber.org/zap"
)

type deleteUserService interface {
        Delete(ctx context.Context, uuid uuid.UUID) error
}

// NewDeleteUserHandler deletes a user by UUID
// @Summary Delete a user by UUID
// @Description Delete a specific user by their UUID
// @Tags users
// @Accept json
// @Produce json
// @Param uuid path string true "User UUID"
// @Success 200 {object} responses.DeleteUserResponse "User deleted successfully"
// @Failure 400 {object} map[string]interface{} "Invalid UUID format"
// @Failure 404 {object} map[string]interface{} "User not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /users/{uuid} [delete]
func NewDeleteUserHandler(service deleteUserService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="5">{
        return func(c *gin.Context) </span><span class="cov10" title="5">{
                uuidParam := c.Param("uuid")
                parsedUUID, err := uuid.Parse(uuidParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("delete user handler: failed to parse uuid: %v", err)
                        logger.Error("failed to parse uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid uuid format"})
                        return
                }</span>

                <span class="cov8" title="4">err = service.Delete(c, parsedUUID)
                if errors.Is(err, domain.ErrUserNotFound) </span><span class="cov1" title="1">{
                        logger.Warn("user not found", zap.String("uuid", uuidParam))
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov7" title="3">if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to delete user", zap.Error(err), zap.String("uuid", uuidParam))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete user"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to delete user", zap.Error(err), zap.String("uuid", uuidParam))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete user"})
                        return
                }</span>

                <span class="cov1" title="1">response := responses.DeleteUserResponse{
                        Message: "User deleted successfully",
                }

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package user

import (
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/user/responses"
)

func mapUserToGetResponse(user *domain.User) responses.GetUserResponse <span class="cov10" title="3">{
        return responses.GetUserResponse{
                UUID:      user.UUID,
                Login:     user.Login,
                Email:     user.Email,
                CreatedAt: user.CreatedAt,
        }
}</span>

func mapUserToUpdateResponse(user *domain.User) responses.UpdateUserResponse <span class="cov1" title="1">{
        return responses.UpdateUserResponse{
                UUID:      user.UUID,
                Login:     user.Login,
                Email:     user.Email,
                CreatedAt: user.CreatedAt,
        }
}</span>

func mapUsersToGetAllResponse(users []*domain.User) []responses.GetUserResponse <span class="cov6" title="2">{
        result := make([]responses.GetUserResponse, len(users))
        for i, user := range users </span><span class="cov6" title="2">{
                result[i] = mapUserToGetResponse(user)
        }</span>
        <span class="cov6" title="2">return result</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package user

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/user/responses"
        "go.uber.org/zap"
)

type getUserService interface {
        GetByUUID(ctx context.Context, uuid uuid.UUID) (*domain.User, error)
}

type getAllUsersService interface {
        GetAll(ctx context.Context) ([]*domain.User, error)
}

// NewGetUserHandler retrieves a user by UUID
// @Summary Get a user by UUID
// @Description Retrieve a specific user by their UUID
// @Tags users
// @Accept json
// @Produce json
// @Param uuid path string true "User UUID"
// @Success 200 {object} responses.GetUserResponse "User retrieved successfully"
// @Failure 400 {object} map[string]interface{} "Invalid UUID format"
// @Failure 404 {object} map[string]interface{} "User not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /users/{uuid} [get]
func NewGetUserHandler(service getUserService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="5">{
        return func(c *gin.Context) </span><span class="cov10" title="5">{
                uuidParam := c.Param("uuid")
                parsedUUID, err := uuid.Parse(uuidParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("get user handler: failed to parse uuid: %v", err)
                        logger.Error("failed to parse uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid uuid format"})
                        return
                }</span>

                <span class="cov8" title="4">user, err := service.GetByUUID(c, parsedUUID)
                if errors.Is(err, domain.ErrUserNotFound) </span><span class="cov1" title="1">{
                        logger.Warn("user not found", zap.String("uuid", uuidParam))
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov7" title="3">if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to get user", zap.Error(err), zap.String("uuid", uuidParam))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get user"})
                        return
                }</span>
                <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to get user", zap.Error(err), zap.String("uuid", uuidParam))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get user"})
                        return
                }</span>

                <span class="cov1" title="1">response := mapUserToGetResponse(user)

                c.JSON(http.StatusOK, response)</span>
        }
}

// NewGetAllUsersHandler retrieves all users
// @Summary Get all users
// @Description Retrieve a list of all users
// @Tags users
// @Accept json
// @Produce json
// @Success 200 {object} responses.GetAllUsersResponse "Users retrieved successfully"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /users [get]
func NewGetAllUsersHandler(service getAllUsersService, logger *zap.Logger) gin.HandlerFunc <span class="cov8" title="4">{
        return func(c *gin.Context) </span><span class="cov8" title="4">{
                users, err := service.GetAll(c)
                if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to get users", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get users"})
                        return
                }</span>
                <span class="cov7" title="3">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to get users", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get users"})
                        return
                }</span>

                <span class="cov4" title="2">response := responses.GetAllUsersResponse{
                        Users: mapUsersToGetAllResponse(users),
                }

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package requests

import (
        validation "github.com/go-ozzo/ozzo-validation/v4"
)

type UpdateUserRequest struct {
        Login    string `json:"login"`
        Email    string `json:"email"`
        Password string `json:"password"`
}

func (r UpdateUserRequest) Validate() error <span class="cov0" title="0">{
        return validation.ValidateStruct(&amp;r,
                validation.Field(&amp;r.Login, validation.Required, validation.Length(1, 255)),
                validation.Field(&amp;r.Email, validation.Required, validation.Length(1, 255)),
                validation.Field(&amp;r.Password, validation.Required, validation.Length(1, 255)),
        )
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package user

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/handler/user/requests"
        "go.uber.org/zap"
)

type updateUserService interface {
        Update(ctx context.Context, uuid uuid.UUID, login string, email string, password string) (*domain.User, error)
}

// NewUpdateUserHandler updates a user by UUID
// @Summary Update a user by UUID
// @Description Update a specific user's login, email and password by their UUID
// @Tags users
// @Accept json
// @Produce json
// @Param uuid path string true "User UUID"
// @Param request body requests.UpdateUserRequest true "User update request"
// @Success 200 {object} responses.UpdateUserResponse "User updated successfully"
// @Failure 400 {object} map[string]interface{} "Invalid UUID format or validation failed"
// @Failure 404 {object} map[string]interface{} "User not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Router /users/{uuid} [put]
func NewUpdateUserHandler(service updateUserService, logger *zap.Logger) gin.HandlerFunc <span class="cov10" title="9">{
        return func(c *gin.Context) </span><span class="cov10" title="9">{
                uuidParam := c.Param("uuid")
                parsedUUID, err := uuid.Parse(uuidParam)
                if err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update user handler: failed to parse uuid: %v", err)
                        logger.Error("failed to parse uuid", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid uuid format"})
                        return
                }</span>

                <span class="cov9" title="8">var req requests.UpdateUserRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                        err = fmt.Errorf("update user handler: failed to bind request: %v", err)
                        logger.Error("failed to bind request", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request format"})
                        return
                }</span>

                <span class="cov8" title="7">if err := req.Validate(); err != nil </span><span class="cov5" title="3">{
                        err = fmt.Errorf("update user handler: validation failed: %v", err)
                        logger.Error("validation failed", zap.Error(err))
                        c.JSON(http.StatusBadRequest, gin.H{"error": "validation failed", "details": err.Error()})
                        return
                }</span>

                <span class="cov6" title="4">user, err := service.Update(c, parsedUUID, req.Login, req.Email, req.Password)
                if errors.Is(err, domain.ErrUserNotFound) </span><span class="cov1" title="1">{
                        logger.Warn("user not found", zap.String("uuid", uuidParam))
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov5" title="3">if errors.Is(err, domain.ErrInternal) </span><span class="cov1" title="1">{
                        logger.Error("failed to update user", zap.Error(err), zap.String("uuid", uuidParam))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update user"})
                        return
                }</span>
                <span class="cov3" title="2">if err != nil </span><span class="cov1" title="1">{
                        logger.Error("failed to update user", zap.Error(err), zap.String("uuid", uuidParam))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update user"})
                        return
                }</span>

                <span class="cov1" title="1">response := mapUserToUpdateResponse(user)

                c.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package middleware

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"

        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

type userRepository interface {
        GetByUUID(ctx context.Context, uuid uuid.UUID) (*domain.User, error)
}

func AuthMiddleware(userRepo userRepository, secretToken string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                tokenString, err := c.Cookie("accessToken")
                if err != nil || tokenString == "" </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "authorization token required"})
                        return
                }</span>

                <span class="cov0" title="0">if secretToken == "" </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "server misconfiguration"})
                        return
                }</span>

                <span class="cov0" title="0">token, err := jwt.ParseWithClaims(tokenString, &amp;jwt.RegisteredClaims{}, func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov0" title="0">return []byte(secretToken), nil</span>
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
                        return
                }</span>

                <span class="cov0" title="0">claims, ok := token.Claims.(*jwt.RegisteredClaims)
                if !ok || !token.Valid </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid token claims"})
                        return
                }</span>

                <span class="cov0" title="0">if claims.ExpiresAt != nil &amp;&amp; time.Now().After(claims.ExpiresAt.Time) </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "token expired"})
                        return
                }</span>

                <span class="cov0" title="0">uid, err := uuid.Parse(claims.Subject)
                if err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid uuid format in token"})
                        return
                }</span>

                <span class="cov0" title="0">user, err := userRepo.GetByUUID(c.Request.Context(), uid)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, domain.ErrInternal) </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "failed to fetch user"})
                                return
                        }</span>
                        <span class="cov0" title="0">c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
                        return</span>
                }

                <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
                        return
                }</span>

                <span class="cov0" title="0">c.Set("user_uid", user.UUID)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package document

import (
        "context"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *DocumentRepository) Create(ctx context.Context, groupUUID uuid.UUID, name, content string) (*domain.Document, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO documents (group_uuid, name, content) 
                VALUES ($1, $2, $3) 
                RETURNING uuid, group_uuid, name, content, created_at`

        var document domain.Document
        err := r.db.QueryRowContext(ctx, query, groupUUID, name, content).Scan(
                &amp;document.UUID,
                &amp;document.GroupUUID,
                &amp;document.Name,
                &amp;document.Content,
                &amp;document.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("document repository: create: %w", err))
        }</span>

        <span class="cov0" title="0">return &amp;document, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package document

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *DocumentRepository) Delete(ctx context.Context, uuid uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM documents WHERE uuid = $1`

        result, err := r.db.ExecContext(ctx, query, uuid)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(domain.ErrInternal, fmt.Errorf("document repository: delete exec: %w", err))
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(domain.ErrInternal, fmt.Errorf("document repository: delete rows affected: %w", err))
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package document

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *DocumentRepository) GetByUUID(ctx context.Context, uuid uuid.UUID) (*domain.Document, error) <span class="cov0" title="0">{
        query := `
                SELECT uuid, group_uuid, name, content, created_at 
                FROM documents 
                WHERE uuid = $1`

        var document domain.Document
        err := r.db.QueryRowContext(ctx, query, uuid).Scan(
                &amp;document.UUID,
                &amp;document.GroupUUID,
                &amp;document.Name,
                &amp;document.Content,
                &amp;document.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Join(domain.ErrInternal, fmt.Errorf("document repository: getByUUID: %w", err))</span>
        }

        <span class="cov0" title="0">return &amp;document, nil</span>
}

func (r *DocumentRepository) GetAll(ctx context.Context) ([]*domain.Document, error) <span class="cov0" title="0">{
        query := `
                SELECT uuid, group_uuid, name, content, created_at 
                FROM documents 
                ORDER BY created_at DESC`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("document repository: getAll query: %w", err))
        }</span>
        <span class="cov0" title="0">defer rows.Close() //nolint:errcheck

        var documents []*domain.Document
        for rows.Next() </span><span class="cov0" title="0">{
                var document domain.Document
                err := rows.Scan(
                        &amp;document.UUID,
                        &amp;document.GroupUUID,
                        &amp;document.Name,
                        &amp;document.Content,
                        &amp;document.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Join(domain.ErrInternal, fmt.Errorf("document repository: getAll scan: %w", err))
                }</span>
                <span class="cov0" title="0">documents = append(documents, &amp;document)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("document repository: getAll rows err: %w", err))
        }</span>

        <span class="cov0" title="0">return documents, nil</span>
}

func (r *DocumentRepository) GetAllForUser(ctx context.Context, userUUID uuid.UUID) ([]*domain.Document, error) <span class="cov0" title="0">{
        query := `
                SELECT d.uuid, d.group_uuid, d.name, d.content, d.created_at
                FROM documents d
                INNER JOIN user_groups ug ON ug.group_uuid = d.group_uuid
                WHERE ug.user_uuid = $1
                ORDER BY d.created_at DESC`

        rows, err := r.db.QueryContext(ctx, query, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("document repository: getAllForUser query: %w", err))
        }</span>
        <span class="cov0" title="0">defer rows.Close() //nolint:errcheck

        var documents []*domain.Document
        for rows.Next() </span><span class="cov0" title="0">{
                var document domain.Document
                err := rows.Scan(
                        &amp;document.UUID,
                        &amp;document.GroupUUID,
                        &amp;document.Name,
                        &amp;document.Content,
                        &amp;document.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Join(domain.ErrInternal, fmt.Errorf("document repository: getAllForUser scan: %w", err))
                }</span>
                <span class="cov0" title="0">documents = append(documents, &amp;document)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("document repository: getAllForUser rows err: %w", err))
        }</span>

        <span class="cov0" title="0">return documents, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package document

import (
        "database/sql"
)

type DocumentRepository struct {
        db *sql.DB
}

func NewDocumentRepository(db *sql.DB) *DocumentRepository <span class="cov0" title="0">{
        return &amp;DocumentRepository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package document

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *DocumentRepository) Update(ctx context.Context, uuid uuid.UUID, name, content string) (*domain.Document, error) <span class="cov0" title="0">{
        query := `
                UPDATE documents 
                SET name = $1, content = $2 
                WHERE uuid = $3 
                RETURNING uuid, group_uuid, name, content, created_at`

        var document domain.Document
        err := r.db.QueryRowContext(ctx, query, name, content, uuid).Scan(
                &amp;document.UUID,
                &amp;document.GroupUUID,
                &amp;document.Name,
                &amp;document.Content,
                &amp;document.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Join(domain.ErrInternal, fmt.Errorf("document repository: update: %w", err))</span>
        }

        <span class="cov0" title="0">return &amp;document, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package group

import (
        "context"
        "errors"
        "fmt"

        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *GroupRepository) Create(ctx context.Context, name string) (*domain.Group, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO groups (name) 
                VALUES ($1) 
                RETURNING uuid, name, created_at`

        var group domain.Group
        err := r.db.QueryRowContext(ctx, query, name).Scan(
                &amp;group.UUID,
                &amp;group.Name,
                &amp;group.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: create: %w", err))
        }</span>

        <span class="cov0" title="0">return &amp;group, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package group

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *GroupRepository) Delete(ctx context.Context, uuid uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM groups WHERE uuid = $1`

        result, err := r.db.ExecContext(ctx, query, uuid)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(domain.ErrInternal, fmt.Errorf("group repository: delete exec: %w", err))
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(domain.ErrInternal, fmt.Errorf("group repository: delete rows affected: %w", err))
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package group

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *GroupRepository) GetByUUID(ctx context.Context, uuid uuid.UUID) (*domain.Group, error) <span class="cov0" title="0">{
        query := `
                SELECT uuid, name, created_at 
                FROM groups 
                WHERE uuid = $1`

        var group domain.Group
        err := r.db.QueryRowContext(ctx, query, uuid).Scan(
                &amp;group.UUID,
                &amp;group.Name,
                &amp;group.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: getByUUID: %w", err))</span>
        }

        <span class="cov0" title="0">return &amp;group, nil</span>
}

func (r *GroupRepository) IsMember(ctx context.Context, groupUUID, userUUID uuid.UUID) (bool, error) <span class="cov0" title="0">{
        const query = `
                SELECT EXISTS (
                        SELECT 1
                        FROM user_groups
                        WHERE group_uuid = $1 AND user_uuid = $2
                )`
        var exists bool
        err := r.db.QueryRowContext(ctx, query, groupUUID, userUUID).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: isMember query: %w", err))
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}

func (r *GroupRepository) GetAll(ctx context.Context) ([]*domain.Group, error) <span class="cov0" title="0">{
        query := `
                SELECT uuid, name, created_at 
                FROM groups 
                ORDER BY created_at DESC`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: getAll query: %w", err))
        }</span>
        <span class="cov0" title="0">defer rows.Close() //nolint:errcheck

        var groups []*domain.Group
        for rows.Next() </span><span class="cov0" title="0">{
                var group domain.Group
                err := rows.Scan(
                        &amp;group.UUID,
                        &amp;group.Name,
                        &amp;group.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: getAll scan: %w", err))
                }</span>
                <span class="cov0" title="0">groups = append(groups, &amp;group)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: getAll rows err: %w", err))
        }</span>

        <span class="cov0" title="0">return groups, nil</span>
}

func (r *GroupRepository) GetAllForUser(ctx context.Context, userUUID uuid.UUID) ([]*domain.Group, error) <span class="cov0" title="0">{
        query := `
                SELECT g.uuid, g.name, g.created_at
                FROM groups g
                INNER JOIN user_groups ug ON ug.group_uuid = g.uuid
                WHERE ug.user_uuid = $1
                ORDER BY g.created_at DESC`

        rows, err := r.db.QueryContext(ctx, query, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: getAllForUser query: %w", err))
        }</span>
        <span class="cov0" title="0">defer rows.Close() //nolint:errcheck

        var groups []*domain.Group
        for rows.Next() </span><span class="cov0" title="0">{
                var group domain.Group
                err := rows.Scan(
                        &amp;group.UUID,
                        &amp;group.Name,
                        &amp;group.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: getAllForUser scan: %w", err))
                }</span>
                <span class="cov0" title="0">groups = append(groups, &amp;group)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: getAllForUser rows err: %w", err))
        }</span>

        <span class="cov0" title="0">return groups, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package group

import (
        "database/sql"
)

type GroupRepository struct {
        db *sql.DB
}

func NewGroupRepository(db *sql.DB) *GroupRepository <span class="cov0" title="0">{
        return &amp;GroupRepository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package group

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *GroupRepository) Update(ctx context.Context, uuid uuid.UUID, name string) (*domain.Group, error) <span class="cov0" title="0">{
        query := `
                UPDATE groups 
                SET name = $1 
                WHERE uuid = $2 
                RETURNING uuid, name, created_at`

        var group domain.Group
        err := r.db.QueryRowContext(ctx, query, name, uuid).Scan(
                &amp;group.UUID,
                &amp;group.Name,
                &amp;group.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: update: %w", err))</span>
        }

        <span class="cov0" title="0">return &amp;group, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package member

import (
        "context"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *MemberRepository) CreateMember(ctx context.Context, groupUUID, userUUID uuid.UUID, role string) (*domain.Member, error) <span class="cov0" title="0">{
        const query = `
                INSERT INTO user_groups (group_uuid, user_uuid, role)
                VALUES ($1, $2, $3)
                RETURNING group_uuid, user_uuid, role, created_at`

        var member domain.Member
        err := r.db.QueryRowContext(ctx, query, groupUUID, userUUID, role).Scan(
                &amp;member.GroupUUID,
                &amp;member.UserUUID,
                &amp;member.Role,
                &amp;member.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("member repository: create member: %w", err))
        }</span>

        <span class="cov0" title="0">return &amp;member, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package member

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *MemberRepository) DeleteMember(ctx context.Context, groupUUID, userUUID uuid.UUID) error <span class="cov0" title="0">{
        const query = `
                DELETE FROM user_groups
                WHERE group_uuid = $1 AND user_uuid = $2`

        result, err := r.db.ExecContext(ctx, query, groupUUID, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(domain.ErrInternal, fmt.Errorf("group repository: delete member exec: %w", err))
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(domain.ErrInternal, fmt.Errorf("group repository: delete member rows affected: %w", err))
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package member

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *MemberRepository) GetMember(ctx context.Context, groupUUID, userUUID uuid.UUID) (*domain.Member, error) <span class="cov0" title="0">{
        const query = `
                SELECT group_uuid, user_uuid, role, created_at
                FROM user_groups
                WHERE group_uuid = $1 AND user_uuid = $2`

        var member domain.Member
        err := r.db.QueryRowContext(ctx, query, groupUUID, userUUID).Scan(
                &amp;member.GroupUUID,
                &amp;member.UserUUID,
                &amp;member.Role,
                &amp;member.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: get member: %w", err))</span>
        }

        <span class="cov0" title="0">return &amp;member, nil</span>
}

func (r *MemberRepository) GetAllMembers(ctx context.Context, groupUUID uuid.UUID) ([]*domain.Member, error) <span class="cov0" title="0">{
        const query = `
                SELECT group_uuid, user_uuid, role, created_at
                FROM user_groups
                WHERE group_uuid = $1
                ORDER BY created_at DESC`

        rows, err := r.db.QueryContext(ctx, query, groupUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: get all members query: %w", err))
        }</span>
        <span class="cov0" title="0">defer rows.Close() //nolint:errcheck

        var members []*domain.Member
        for rows.Next() </span><span class="cov0" title="0">{
                var member domain.Member
                err = rows.Scan(
                        &amp;member.GroupUUID,
                        &amp;member.UserUUID,
                        &amp;member.Role,
                        &amp;member.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: get all members scan: %w", err))
                }</span>
                <span class="cov0" title="0">members = append(members, &amp;member)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: get all members rows err: %w", err))
        }</span>

        <span class="cov0" title="0">return members, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package member

import (
        "database/sql"
)

type MemberRepository struct {
        db *sql.DB
}

func NewMemberRepository(db *sql.DB) *MemberRepository <span class="cov0" title="0">{
        return &amp;MemberRepository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package member

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *MemberRepository) UpdateMember(ctx context.Context, groupUUID, userUUID uuid.UUID, role string) (*domain.Member, error) <span class="cov0" title="0">{
        const query = `
                UPDATE user_groups
                SET role = $3
                WHERE group_uuid = $1 AND user_uuid = $2
                RETURNING group_uuid, user_uuid, role, created_at`

        var member domain.Member
        err := r.db.QueryRowContext(ctx, query, groupUUID, userUUID, role).Scan(
                &amp;member.GroupUUID,
                &amp;member.UserUUID,
                &amp;member.Role,
                &amp;member.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Join(domain.ErrInternal, fmt.Errorf("group repository: update member: %w", err))</span>
        }

        <span class="cov0" title="0">return &amp;member, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package reg

import (
        "context"
        "errors"
        "fmt"

        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *RegRepository) Register(ctx context.Context, login string, email string, password string) (*domain.User, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO users (login, email, hashed_password) 
                VALUES ($1, $2, $3) 
                RETURNING uuid, login, email, hashed_password, created_at`

        var user domain.User
        err := r.db.QueryRowContext(ctx, query, login, email, password).Scan(
                &amp;user.UUID,
                &amp;user.Login,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("reg repository: register: %w", err))
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package reg

import (
        "database/sql"
)

type RegRepository struct {
        db *sql.DB
}

func NewRegRepository(db *sql.DB) *RegRepository <span class="cov0" title="0">{
        return &amp;RegRepository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package user

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *UserRepository) Delete(ctx context.Context, uuid uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM users WHERE uuid = $1`

        result, err := r.db.ExecContext(ctx, query, uuid)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(domain.ErrInternal, fmt.Errorf("user repository: delete exec: %w", err))
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(domain.ErrInternal, fmt.Errorf("user repository: delete rows affected: %w", err))
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return sql.ErrNoRows
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package user

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *UserRepository) GetByUUID(ctx context.Context, uuid uuid.UUID) (*domain.User, error) <span class="cov0" title="0">{
        query := `
                SELECT uuid, login, email, hashed_password, created_at 
                FROM users 
                WHERE uuid = $1`

        var user domain.User
        err := r.db.QueryRowContext(ctx, query, uuid).Scan(
                &amp;user.UUID,
                &amp;user.Login,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Join(domain.ErrInternal, fmt.Errorf("user repository: getByUUID: %w", err))</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *UserRepository) GetByLogin(ctx context.Context, login string) (*domain.User, error) <span class="cov0" title="0">{
        query := `
    SELECT uuid, login, email, hashed_password, created_at 
    FROM users 
    WHERE login = $1`

        var user domain.User
        err := r.db.QueryRowContext(ctx, query, login).Scan(
                &amp;user.UUID,
                &amp;user.Login,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Join(domain.ErrInternal, fmt.Errorf("user repository: getByLogin: %w", err))</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *UserRepository) GetAll(ctx context.Context) ([]*domain.User, error) <span class="cov0" title="0">{
        query := `
                SELECT uuid, login, email, hashed_password, created_at 
                FROM users 
                ORDER BY created_at DESC`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("user repository: getAll query: %w", err))
        }</span>
        <span class="cov0" title="0">defer rows.Close() //nolint:errcheck

        var users []*domain.User
        for rows.Next() </span><span class="cov0" title="0">{
                var user domain.User
                err := rows.Scan(
                        &amp;user.UUID,
                        &amp;user.Login,
                        &amp;user.Email,
                        &amp;user.Password,
                        &amp;user.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Join(domain.ErrInternal, fmt.Errorf("user repository: getAll scan: %w", err))
                }</span>
                <span class="cov0" title="0">users = append(users, &amp;user)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("user repository: getAll rows err: %w", err))
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package user

import (
        "database/sql"
)

type UserRepository struct {
        db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package user

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (r *UserRepository) Update(ctx context.Context, uuid uuid.UUID, login string, email string, password string) (*domain.User, error) <span class="cov0" title="0">{
        query := `
                UPDATE users 
                SET login = $1, email = $2, hashed_password = $3
                WHERE uuid = $4
                RETURNING uuid, login, email, hashed_password, created_at`

        var user domain.User
        err := r.db.QueryRowContext(ctx, query, login, email, password, uuid).Scan(
                &amp;user.UUID,
                &amp;user.Login,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, errors.Join(domain.ErrInternal, fmt.Errorf("user repository: update: %w", err))</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package document

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *DocumentService) Create(ctx context.Context, groupUUID uuid.UUID, name, content string) (*domain.Document, error) <span class="cov0" title="0">{
        document, err := s.repo.Create(ctx, groupUUID, name, content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document service: create: %w", err)
        }</span>

        <span class="cov0" title="0">return document, nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package document

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *DocumentService) Delete(ctx context.Context, uuid uuid.UUID) error <span class="cov0" title="0">{
        err := s.repo.Delete(ctx, uuid)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return domain.ErrDocumentNotFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("document service: delete: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package document

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *DocumentService) GetByUUID(ctx context.Context, uuid uuid.UUID) (*domain.Document, error) <span class="cov0" title="0">{
        document, err := s.repo.GetByUUID(ctx, uuid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document service: getByUUID: %w", err)
        }</span>

        <span class="cov0" title="0">if document == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrDocumentNotFound
        }</span>

        <span class="cov0" title="0">return document, nil</span>
}

func (s *DocumentService) GetByUUIDForUser(ctx context.Context, documentUUID, userUUID uuid.UUID) (*domain.Document, error) <span class="cov0" title="0">{
        document, err := s.GetByUUID(ctx, documentUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">isMember, err := s.groupRepo.IsMember(ctx, document.GroupUUID, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document service: getByUUIDForUser: %w", err)
        }</span>

        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                return nil, domain.ErrForbidden
        }</span>

        <span class="cov0" title="0">return document, nil</span>
}

func (s *DocumentService) GetAll(ctx context.Context) ([]*domain.Document, error) <span class="cov0" title="0">{
        documents, err := s.repo.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document service: getAll: %w", err)
        }</span>

        <span class="cov0" title="0">return documents, nil</span>
}

func (s *DocumentService) GetAllForUser(ctx context.Context, userUUID uuid.UUID) ([]*domain.Document, error) <span class="cov0" title="0">{
        documents, err := s.repo.GetAllForUser(ctx, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document service: getAllForUser: %w", err)
        }</span>

        <span class="cov0" title="0">return documents, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package document

import (
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/document"
        grouprepo "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/group"
)

type DocumentService struct {
        repo      *document.DocumentRepository
        groupRepo *grouprepo.GroupRepository
}

func NewDocumentService(repo *document.DocumentRepository, groupRepo *grouprepo.GroupRepository) *DocumentService <span class="cov0" title="0">{
        return &amp;DocumentService{
                repo:      repo,
                groupRepo: groupRepo,
        }
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package document

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *DocumentService) Update(ctx context.Context, uuid uuid.UUID, name, content string) (*domain.Document, error) <span class="cov0" title="0">{
        document, err := s.repo.Update(ctx, uuid, name, content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document service: update: %w", err)
        }</span>

        <span class="cov0" title="0">if document == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrDocumentNotFound
        }</span>

        <span class="cov0" title="0">return document, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package group

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *GroupService) Create(ctx context.Context, ownerUUID uuid.UUID, name string) (*domain.Group, error) <span class="cov0" title="0">{
        group, err := s.repo.Create(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("group service: create: %w", err)
        }</span>

        // unlucky if fails
        <span class="cov0" title="0">_, _ = s.memberRepo.CreateMember(ctx, group.UUID, ownerUUID, domain.RoleAuthor) //nolint:errcheck

        return group, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package group

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *GroupService) Delete(ctx context.Context, uuid uuid.UUID) error <span class="cov0" title="0">{
        err := s.repo.Delete(ctx, uuid)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return domain.ErrGroupNotFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("group service: delete: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package group

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *GroupService) GetByUUID(ctx context.Context, uuid uuid.UUID) (*domain.Group, error) <span class="cov0" title="0">{
        group, err := s.repo.GetByUUID(ctx, uuid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("group service: getByUUID: %w", err)
        }</span>

        <span class="cov0" title="0">if group == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrGroupNotFound
        }</span>

        <span class="cov0" title="0">return group, nil</span>
}

func (s *GroupService) GetByUUIDForUser(ctx context.Context, groupUUID, userUUID uuid.UUID) (*domain.Group, error) <span class="cov0" title="0">{
        isMember, err := s.repo.IsMember(ctx, groupUUID, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("group service: getByUUIDForUser: %w", err)
        }</span>
        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                return nil, domain.ErrForbidden
        }</span>

        <span class="cov0" title="0">group, err := s.repo.GetByUUID(ctx, groupUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("group service: getByUUIDForUser: %w", err)
        }</span>

        <span class="cov0" title="0">if group == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrGroupNotFound
        }</span>

        <span class="cov0" title="0">return group, nil</span>
}

func (s *GroupService) GetAll(ctx context.Context) ([]*domain.Group, error) <span class="cov0" title="0">{
        groups, err := s.repo.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("group service: getAll: %w", err)
        }</span>

        <span class="cov0" title="0">return groups, nil</span>
}

func (s *GroupService) GetAllForUser(ctx context.Context, userUUID uuid.UUID) ([]*domain.Group, error) <span class="cov0" title="0">{
        groups, err := s.repo.GetAllForUser(ctx, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("group service: getAllForUser: %w", err)
        }</span>

        <span class="cov0" title="0">return groups, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package group

import (
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/group"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/member"
)

type GroupService struct {
        repo       *group.GroupRepository
        memberRepo *member.MemberRepository
}

func NewGroupService(repo *group.GroupRepository, memberRepo *member.MemberRepository) *GroupService <span class="cov0" title="0">{
        return &amp;GroupService{
                repo:       repo,
                memberRepo: memberRepo,
        }
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package group

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *GroupService) Update(ctx context.Context, uuid uuid.UUID, name string) (*domain.Group, error) <span class="cov0" title="0">{
        group, err := s.repo.Update(ctx, uuid, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("group service: update: %w", err)
        }</span>

        <span class="cov0" title="0">if group == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrGroupNotFound
        }</span>

        <span class="cov0" title="0">return group, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package member

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *MemberService) CreateMemberByUser(ctx context.Context, userUUID, groupUUID, memberUUID uuid.UUID,
        role string) (*domain.Member, error) <span class="cov0" title="0">{
        group, err := s.groupRepo.GetByUUID(ctx, groupUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: create member get group: %w", err)
        }</span>
        <span class="cov0" title="0">if group == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrGroupNotFound
        }</span>

        <span class="cov0" title="0">if role == domain.RoleAuthor </span><span class="cov0" title="0">{
                return nil, domain.ErrOnlyAuthor
        }</span>

        <span class="cov0" title="0">member, err := s.repo.GetMember(ctx, groupUUID, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: create member get actor: %w", err)
        }</span>
        <span class="cov0" title="0">if member == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrForbidden
        }</span>
        <span class="cov0" title="0">if member.Role != domain.RoleAuthor </span><span class="cov0" title="0">{
                return nil, domain.ErrForbidden
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetByUUID(ctx, memberUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: create member get user: %w", err)
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">existingMember, err := s.repo.GetMember(ctx, groupUUID, memberUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: create member get existing: %w", err)
        }</span>
        <span class="cov0" title="0">if existingMember != nil </span><span class="cov0" title="0">{
                return nil, domain.ErrAlreadyExists
        }</span>

        <span class="cov0" title="0">createdMember, err := s.repo.CreateMember(ctx, groupUUID, memberUUID, role)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: create: %w", err)
        }</span>

        <span class="cov0" title="0">return createdMember, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package member

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *MemberService) DeleteMemberByUser(ctx context.Context, userUUID, groupUUID, memberUUID uuid.UUID) error <span class="cov0" title="0">{
        group, err := s.groupRepo.GetByUUID(ctx, groupUUID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("member service: delete member get group: %w", err)
        }</span>
        <span class="cov0" title="0">if group == nil </span><span class="cov0" title="0">{
                return domain.ErrGroupNotFound
        }</span>

        <span class="cov0" title="0">actor, err := s.repo.GetMember(ctx, groupUUID, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("member service: delete member get actor: %w", err)
        }</span>
        <span class="cov0" title="0">if actor == nil </span><span class="cov0" title="0">{
                return domain.ErrForbidden
        }</span>
        <span class="cov0" title="0">if actor.Role != domain.RoleAuthor </span><span class="cov0" title="0">{
                return domain.ErrForbidden
        }</span>

        <span class="cov0" title="0">targetMember, err := s.repo.GetMember(ctx, groupUUID, memberUUID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("member service: delete member get target: %w", err)
        }</span>
        <span class="cov0" title="0">if targetMember == nil </span><span class="cov0" title="0">{
                return domain.ErrUserNotFound
        }</span>
        <span class="cov0" title="0">if targetMember.Role == domain.RoleAuthor </span><span class="cov0" title="0">{
                return domain.ErrOnlyAuthor
        }</span>

        <span class="cov0" title="0">if err := s.repo.DeleteMember(ctx, groupUUID, memberUUID); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return domain.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("member service: delete member: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package member

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *MemberService) GetAllMembersForUser(ctx context.Context, userUUID, groupUUID uuid.UUID) ([]*domain.Member, error) <span class="cov0" title="0">{
        group, err := s.groupRepo.GetByUUID(ctx, groupUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: get all members get group: %w", err)
        }</span>
        <span class="cov0" title="0">if group == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrGroupNotFound
        }</span>

        <span class="cov0" title="0">member, err := s.repo.GetMember(ctx, groupUUID, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: get all members get actor: %w", err)
        }</span>
        <span class="cov0" title="0">if member == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrForbidden
        }</span>

        <span class="cov0" title="0">members, err := s.repo.GetAllMembers(ctx, groupUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: get all members: %w", err)
        }</span>

        <span class="cov0" title="0">return members, nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package member

import (
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/group"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/member"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/user"
)

type MemberService struct {
        repo      *member.MemberRepository
        groupRepo *group.GroupRepository
        userRepo  *user.UserRepository
}

func NewMemberService(repo *member.MemberRepository, groupRepo *group.GroupRepository,
        userRepo *user.UserRepository) *MemberService <span class="cov0" title="0">{
        return &amp;MemberService{
                repo:      repo,
                groupRepo: groupRepo,
                userRepo:  userRepo,
        }
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package member

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *MemberService) UpdateMemberByUser(ctx context.Context, userUUID, groupUUID, memberUUID uuid.UUID,
        role string) (*domain.Member, error) <span class="cov0" title="0">{
        group, err := s.groupRepo.GetByUUID(ctx, groupUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: update member get group: %w", err)
        }</span>
        <span class="cov0" title="0">if group == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrGroupNotFound
        }</span>

        <span class="cov0" title="0">actor, err := s.repo.GetMember(ctx, groupUUID, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: update member get actor: %w", err)
        }</span>
        <span class="cov0" title="0">if actor == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrForbidden
        }</span>
        <span class="cov0" title="0">if actor.Role != domain.RoleAuthor </span><span class="cov0" title="0">{
                return nil, domain.ErrForbidden
        }</span>

        <span class="cov0" title="0">targetMember, err := s.repo.GetMember(ctx, groupUUID, memberUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: update member get target: %w", err)
        }</span>
        <span class="cov0" title="0">if targetMember == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrUserNotFound
        }</span>
        <span class="cov0" title="0">if targetMember.Role == role </span><span class="cov0" title="0">{
                return targetMember, nil
        }</span>

        <span class="cov0" title="0">if targetMember.Role == domain.RoleAuthor &amp;&amp; role != domain.RoleAuthor </span><span class="cov0" title="0">{
                return nil, domain.ErrOnlyAuthor
        }</span>

        <span class="cov0" title="0">if role == domain.RoleAuthor &amp;&amp; targetMember.Role != domain.RoleAuthor </span><span class="cov0" title="0">{
                member, err := s.repo.UpdateMember(ctx, groupUUID, memberUUID, role)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("member service: update member promote: %w", err)
                }</span>
                <span class="cov0" title="0">if member == nil </span><span class="cov0" title="0">{
                        return nil, domain.ErrUserNotFound
                }</span>

                // unlucky if fails
                <span class="cov0" title="0">_, _ = s.repo.UpdateMember(ctx, groupUUID, actor.UserUUID, domain.RoleEditor) //nolint:errcheck

                return member, nil</span>
        }

        <span class="cov0" title="0">member, err := s.repo.UpdateMember(ctx, groupUUID, memberUUID, role)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("member service: update member: %w", err)
        }</span>
        <span class="cov0" title="0">if member == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">return member, nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package reg

import (
        "context"
        "fmt"

        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "golang.org/x/crypto/bcrypt"
)

func (s *RegService) Register(ctx context.Context, login string, email string, password string) (*domain.User, error) <span class="cov0" title="0">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), s.hashingCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("registration service: %w", err)
        }</span>

        <span class="cov0" title="0">user, err := s.repo.Register(ctx, login, email, string(hashedPassword))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("registration service: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package reg

import (
        "context"

        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

type RegRepository interface {
        Register(ctx context.Context, login string, email string, password string) (*domain.User, error)
}

type RegService struct {
        repo        RegRepository
        hashingCost int
}

func NewRegService(repo RegRepository, cost int) *RegService <span class="cov0" title="0">{
        return &amp;RegService{
                repo:        repo,
                hashingCost: cost,
        }
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package user

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *UserService) Delete(ctx context.Context, uuid uuid.UUID) error <span class="cov0" title="0">{
        err := s.repo.Delete(ctx, uuid)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return domain.ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("user service: delete: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package user

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

func (s *UserService) GetByUUID(ctx context.Context, uuid uuid.UUID) (*domain.User, error) <span class="cov0" title="0">{
        user, err := s.repo.GetByUUID(ctx, uuid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user service: getByUUID: %w", err)
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (s *UserService) GetAll(ctx context.Context) ([]*domain.User, error) <span class="cov0" title="0">{
        users, err := s.repo.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user service: getAll: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package user

import (
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/repo/user"
)

type UserService struct {
        repo        *user.UserRepository
        hashingCost int
}

func NewUserService(repo *user.UserRepository, hashingCost int) *UserService <span class="cov0" title="0">{
        return &amp;UserService{
                repo:        repo,
                hashingCost: hashingCost,
        }
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package user

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
        "golang.org/x/crypto/bcrypt"
)

func (s *UserService) Update(ctx context.Context, uuid uuid.UUID, login string, email string, password string) (*domain.User, error) <span class="cov0" title="0">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), s.hashingCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user service: hash password: %w", err)
        }</span>

        <span class="cov0" title="0">user, err := s.repo.Update(ctx, uuid, login, email, string(hashedPassword))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user service: update: %w", err)
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, domain.ErrUserNotFound
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package logging

import (
        "os"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

func NewLogger() *zap.Logger <span class="cov0" title="0">{
        encoderCfg := zap.NewProductionEncoderConfig()
        encoderCfg.EncodeTime = zapcore.ISO8601TimeEncoder
        consoleEncoder := zapcore.NewConsoleEncoder(encoderCfg)
        consoleWriter := zapcore.Lock(os.Stdout)

        level := zapcore.InfoLevel
        consoleCore := zapcore.NewCore(consoleEncoder, consoleWriter, level)
        core := zapcore.NewTee(consoleCore)
        logger := zap.New(core, zap.AddCaller())
        return logger
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package seeder

import "database/sql"

type Seeder struct {
        db *sql.DB
}

func NewSeeder(db *sql.DB) *Seeder <span class="cov0" title="0">{
        return &amp;Seeder{
                db: db,
        }
}</span>

func (s *Seeder) NewUser() *User <span class="cov0" title="0">{
        return newUser(s.db)
}</span>

func (s *Seeder) GetUserByLogin(login string) (*User, error) <span class="cov0" title="0">{
        return getUserByLogin(s.db, login)
}</span>

func (s *Seeder) GetUserByEmail(email string) (*User, error) <span class="cov0" title="0">{
        return getUserByEmail(s.db, email)
}</span>

func (s *Seeder) GetUserByUUID(uuid string) (*User, error) <span class="cov0" title="0">{
        return getUserByUUID(s.db, uuid)
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package seeder

import (
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/domain"
)

type User struct {
        UUID           string
        Login          string
        Email          string
        HashedPassword string
        CreatedAt      time.Time

        db *sql.DB
}

func (u *User) ToDomain() *domain.User <span class="cov0" title="0">{
        return &amp;domain.User{
                UUID:      uuid.MustParse(u.UUID),
                Login:     u.Login,
                Email:     u.Email,
                Password:  u.HashedPassword,
                CreatedAt: u.CreatedAt,
        }
}</span>

func newUser(db *sql.DB) *User <span class="cov0" title="0">{
        return &amp;User{
                UUID:           uuid.New().String(),
                Login:          "login",
                Email:          "email",
                HashedPassword: "hashedPassword",
                CreatedAt:      time.Now(),

                db: db,
        }
}</span>

func (u *User) WithLogin(login string) *User <span class="cov0" title="0">{
        u.Login = login
        return u
}</span>

func (u *User) WithEmail(email string) *User <span class="cov0" title="0">{
        u.Email = email
        return u
}</span>

func (u *User) WithHashedPassword(hashedPassword string) *User <span class="cov0" title="0">{
        u.HashedPassword = hashedPassword
        return u
}</span>

func (u *User) WithCreatedAt(createdAt time.Time) *User <span class="cov0" title="0">{
        u.CreatedAt = createdAt
        return u
}</span>

func (u *User) WithUUID(uuid string) *User <span class="cov0" title="0">{
        u.UUID = uuid
        return u
}</span>

func (u *User) Create() error <span class="cov0" title="0">{
        query := `
                INSERT INTO users (uuid, login, email, hashed_password, created_at)
                VALUES ($1, $2, $3, $4, $5)
                RETURNING uuid, login, email, hashed_password, created_at`

        err := u.db.QueryRow(query, u.UUID, u.Login, u.Email, u.HashedPassword, u.CreatedAt).Scan( //nolint:noctx
                &amp;u.UUID,
                &amp;u.Login,
                &amp;u.Email,
                &amp;u.HashedPassword,
                &amp;u.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return errors.Join(domain.ErrInternal, fmt.Errorf("user seeder: create: %w", err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func getUserByLogin(db *sql.DB, login string) (*User, error) <span class="cov0" title="0">{
        var user User
        query := `
                SELECT uuid, login, email, hashed_password, created_at
                FROM users
                WHERE login = $1`

        err := db.QueryRow(query, login).Scan( //nolint:noctx
                &amp;user.UUID,
                &amp;user.Login,
                &amp;user.Email,
                &amp;user.HashedPassword,
                &amp;user.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("user seeder: getByLogin: %w", err))
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func getUserByEmail(db *sql.DB, email string) (*User, error) <span class="cov0" title="0">{
        var user User
        query := `
                SELECT uuid, login, email, hashed_password, created_at
                FROM users
                WHERE email = $1`

        err := db.QueryRow(query, email).Scan( //nolint:noctx
                &amp;user.UUID,
                &amp;user.Login,
                &amp;user.Email,
                &amp;user.HashedPassword,
                &amp;user.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("user seeder: getByEmail: %w", err))
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func getUserByUUID(db *sql.DB, uuid string) (*User, error) <span class="cov0" title="0">{
        var user User
        query := `
                SELECT uuid, login, email, hashed_password, created_at
                FROM users
                WHERE uuid = $1`

        err := db.QueryRow(query, uuid).Scan( //nolint:noctx
                &amp;user.UUID,
                &amp;user.Login,
                &amp;user.Email,
                &amp;user.HashedPassword,
                &amp;user.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Join(domain.ErrInternal, fmt.Errorf("user seeder: getByUUID: %w", err))
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package testapp

import (
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/app"
        "github.com/ukma-cs-ssdm-2025/team-circus/internal/config"
        "go.uber.org/zap"
)

const Addr = "http://localhost:8081"

func NewApp() *app.App <span class="cov0" title="0">{
        cfg := config.Config{
                DB: config.DBConfig{
                        Driver: "postgres",
                        Host:   "localhost",
                        Port:   "5433",
                        User:   "postgres",
                        Pass:   "postgres",
                        Name:   "mcd",
                },
                Srv: config.SrvConfig{
                        Port: "8081",
                },
                CORS: config.CORSConfig{
                        AllowOrigins:     []string{"http://localhost:3000"},
                        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE"},
                        AllowHeaders:     []string{"Content-Type", "Authorization"},
                        ExposeHeaders:    []string{"Content-Type", "Authorization"},
                        AllowCredentials: true,
                        MaxAge:           43200,
                },
        }
        return app.New(&amp;cfg, zap.NewNop())
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package testdb

import (
        "database/sql"
        "errors"
)

func NewDB() (*sql.DB, error) <span class="cov0" title="0">{
        db, err := sql.Open("postgres", "host=localhost port=5433 user=postgres password=postgres dbname=mcd sslmode=disable")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return db, nil</span>
}

func ResetDB(db *sql.DB) error <span class="cov0" title="0">{
        var err error
        var errs []error

        _, err = db.Exec("DELETE FROM user_groups") //nolint:noctx
        errs = append(errs, err)
        _, err = db.Exec("DELETE FROM documents") //nolint:noctx
        errs = append(errs, err)
        _, err = db.Exec("DELETE FROM groups") //nolint:noctx
        errs = append(errs, err)
        _, err = db.Exec("DELETE FROM users") //nolint:noctx
        errs = append(errs, err)

        resetErr := errors.Join(errs...)
        return resetErr
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
